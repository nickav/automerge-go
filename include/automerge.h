/** \file
 * All constants, functions and types in the Automerge library's C API.
 */
 

#ifndef AUTOMERGE_H
#define AUTOMERGE_H

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <time.h>


/**
 * \defgroup enumerations Public Enumerations
     Symbolic names for integer constants.
 */

/**
 * \memberof AMdoc
 * \def AM_ROOT
 * \brief The root object of a document.
 */
#define AM_ROOT NULL

/**
 * \memberof AMchangeHash
 * \def AM_CHANGE_HASH_SIZE
 * \brief The count of bytes in a change hash.
 */
#define AM_CHANGE_HASH_SIZE 32


/**
 * \ingroup enumerations
 * \enum AMobjType
 * \brief The type of an object value.
 */
enum AMobjType {
  /**
   * A list.
   */
  AM_OBJ_TYPE_LIST = 1,
  /**
   * A key-value map.
   */
  AM_OBJ_TYPE_MAP,
  /**
   * A list of Unicode graphemes.
   */
  AM_OBJ_TYPE_TEXT,
};
typedef uint8_t AMobjType;

/**
 * \ingroup enumerations
 * \enum AMstatus
 * \brief The status of an API call.
 */
enum AMstatus {
  /**
   * Success.
   * \note This tag is unalphabetized so that `0` indicates success.
   */
  AM_STATUS_OK,
  /**
   * Failure due to an error.
   */
  AM_STATUS_ERROR,
  /**
   * Failure due to an invalid result.
   */
  AM_STATUS_INVALID_RESULT,
};
typedef uint8_t AMstatus;

/**
 * \struct AMactorId
 * \installed_headerfile
 * \brief An actor's unique identifier.
 */
typedef struct AMactorId AMactorId;

/**
 * \struct AMchange
 * \installed_headerfile
 * \brief A group of operations performed by an actor.
 */
typedef struct AMchange AMchange;

/**
 * \struct AMdoc
 * \installed_headerfile
 * \brief A JSON-like CRDT.
 */
typedef struct AMdoc AMdoc;

/**
 * \struct AMlistItem
 * \installed_headerfile
 * \brief An item in a list object.
 */
typedef struct AMlistItem AMlistItem;

/**
 * \struct AMmapItem
 * \installed_headerfile
 * \brief An item in a map object.
 */
typedef struct AMmapItem AMmapItem;

/**
 * \struct AMobjId
 * \installed_headerfile
 * \brief An object's unique identifier.
 */
typedef struct AMobjId AMobjId;

/**
 * \struct AMobjItem
 * \installed_headerfile
 * \brief An item in an object.
 */
typedef struct AMobjItem AMobjItem;

/**
 * \struct AMresult
 * \installed_headerfile
 * \brief A discriminated union of result variants.
 */
typedef struct AMresult AMresult;

/**
 * \struct AMsyncHave
 * \installed_headerfile
 * \brief A summary of the changes that the sender of a synchronization
 *        message already has.
 */
typedef struct AMsyncHave AMsyncHave;

/**
 * \struct AMsyncMessage
 * \installed_headerfile
 * \brief A synchronization message for a peer.
 */
typedef struct AMsyncMessage AMsyncMessage;

/**
 * \struct AMsyncState
 * \installed_headerfile
 * \brief The state of synchronization with a peer.
 */
typedef struct AMsyncState AMsyncState;

/**
 * \struct AMbyteSpan
 * \installed_headerfile
 * \brief A view onto a contiguous sequence of bytes.
 */
typedef struct AMbyteSpan {
  /**
   * A pointer to an array of bytes.
   * \attention <b>NEVER CALL `free()` ON \p src!</b>
   * \warning \p src is only valid until the `AMfree()` function is called
   *          on the `AMresult` struct that stores the array of bytes to
   *          which it points.
   */
  const uint8_t *src;
  /**
   * The number of bytes in the array.
   */
  size_t count;
} AMbyteSpan;

/**
 * \struct AMchangeHashes
 * \installed_headerfile
 * \brief A random-access iterator over a sequence of change hashes.
 */
typedef struct AMchangeHashes {
  /**
   * An implementation detail that is intentionally opaque.
   * \warning Modifying \p detail will cause undefined behavior.
   * \note The actual size of \p detail will vary by platform, this is just
   *       the one for the platform this documentation was built on.
   */
  uint8_t detail[+8+8+8];
} AMchangeHashes;

/**
 * \struct AMchanges
 * \installed_headerfile
 * \brief A random-access iterator over a sequence of changes.
 */
typedef struct AMchanges {
  /**
   * An implementation detail that is intentionally opaque.
   * \warning Modifying \p detail will cause undefined behavior.
   * \note The actual size of \p detail will vary by platform, this is just
   *       the one for the platform this documentation was built on.
   */
  uint8_t detail[+8+8+8+8];
} AMchanges;

/**
 * \struct AMlistItems
 * \installed_headerfile
 * \brief A random-access iterator over a sequence of list object items.
 */
typedef struct AMlistItems {
  /**
   * An implementation detail that is intentionally opaque.
   * \warning Modifying \p detail will cause undefined behavior.
   * \note The actual size of \p detail will vary by platform, this is just
   *       the one for the platform this documentation was built on.
   */
  uint8_t detail[+8+8+8];
} AMlistItems;

/**
 * \struct AMmapItems
 * \installed_headerfile
 * \brief A random-access iterator over a sequence of map object items.
 */
typedef struct AMmapItems {
  /**
   * An implementation detail that is intentionally opaque.
   * \warning Modifying \p detail will cause undefined behavior.
   * \note The actual size of \p detail will vary by platform, this is just
   *       the one for the platform this documentation was built on.
   */
  uint8_t detail[+8+8+8];
} AMmapItems;

/**
 * \struct AMobjItems
 * \installed_headerfile
 * \brief A random-access iterator over a sequence of object items.
 */
typedef struct AMobjItems {
  /**
   * An implementation detail that is intentionally opaque.
   * \warning Modifying \p detail will cause undefined behavior.
   * \note The actual size of \p detail will vary by platform, this is just
   *       the one for the platform this documentation was built on.
   */
  uint8_t detail[+8+8+8];
} AMobjItems;

/**
 * \struct AMstrs
 * \installed_headerfile
 * \brief A random-access iterator over a sequence of UTF-8 strings.
 */
typedef struct AMstrs {
  /**
   * An implementation detail that is intentionally opaque.
   * \warning Modifying \p detail will cause undefined behavior.
   * \note The actual size of \p detail will vary by platform, this is just
   *       the one for the platform this documentation was built on.
   */
  uint8_t detail[+8+8+8];
} AMstrs;

/**
 * \struct AMunknownValue
 * \installed_headerfile
 * \brief A value (typically for a `set` operation) whose type is unknown.
 *
 */
typedef struct AMunknownValue {
  /**
   * The value's raw bytes.
   */
  struct AMbyteSpan bytes;
  /**
   * The value's encoded type identifier.
   */
  uint8_t type_code;
} AMunknownValue;

/**
 * \struct AMvalue
 * \installed_headerfile
 * \brief A discriminated union of value type variants for a result.
 *
 * \enum AMvalueVariant
 * \brief A value type discriminant.
 *
 * \var AMvalue::actor_id
 * An actor identifier as a pointer to an `AMactorId` struct.
 *
 * \var AMvalue::boolean
 * A boolean.
 *
 * \var AMvalue::bytes
 * A sequence of bytes as an `AMbyteSpan` struct.
 *
 * \var AMvalue::change_hashes
 * A sequence of change hashes as an `AMchangeHashes` struct.
 *
 * \var AMvalue::changes
 * A sequence of changes as an `AMchanges` struct.
 *
 * \var AMvalue::counter
 * A CRDT counter.
 *
 * \var AMvalue::doc
 * A document as a pointer to an `AMdoc` struct.
 *
 * \var AMvalue::f64
 * A 64-bit float.
 *
 * \var AMvalue::int_
 * A 64-bit signed integer.
 *
 * \var AMvalue::list_items
 * A sequence of list object items as an `AMlistItems` struct.
 *
 * \var AMvalue::map_items
 * A sequence of map object items as an `AMmapItems` struct.
 *
 * \var AMvalue::obj_id
 * An object identifier as a pointer to an `AMobjId` struct.
 *
 * \var AMvalue::obj_items
 * A sequence of object items as an `AMobjItems` struct.
 *
 * \var AMvalue::str
 * A UTF-8 string.
 *
 * \var AMvalue::strs
 * A sequence of UTF-8 strings as an `AMstrs` struct.
 *
 * \var AMvalue::sync_message
 * A synchronization message as a pointer to an `AMsyncMessage` struct.
 *
 * \var AMvalue::sync_state
 * A synchronization state as a pointer to an `AMsyncState` struct.
 *
 * \var AMvalue::tag
 * The variant discriminator.
 *
 * \var AMvalue::timestamp
 * A Lamport timestamp.
 *
 * \var AMvalue::uint
 * A 64-bit unsigned integer.
 *
 * \var AMvalue::unknown
 * A value of unknown type as an `AMunknownValue` struct.
 */
enum AMvalueVariant {
  /**
   * A void variant.
   * \note This tag is unalphabetized so that a zeroed struct will have it.
   */
  AM_VALUE_VOID,
  /**
   * An actor identifier variant.
   */
  AM_VALUE_ACTOR_ID,
  /**
   * A boolean variant.
   */
  AM_VALUE_BOOLEAN,
  /**
   * A byte array variant.
   */
  AM_VALUE_BYTES,
  /**
   * A change hashes variant.
   */
  AM_VALUE_CHANGE_HASHES,
  /**
   * A changes variant.
   */
  AM_VALUE_CHANGES,
  /**
   * A CRDT counter variant.
   */
  AM_VALUE_COUNTER,
  /**
   * A document variant.
   */
  AM_VALUE_DOC,
  /**
   * A 64-bit float variant.
   */
  AM_VALUE_F64,
  /**
   * A 64-bit signed integer variant.
   */
  AM_VALUE_INT,
  /**
   * A list items variant.
   */
  AM_VALUE_LIST_ITEMS,
  /**
   * A map items variant.
   */
  AM_VALUE_MAP_ITEMS,
  /**
   * A null variant.
   */
  AM_VALUE_NULL,
  /**
   * An object identifier variant.
   */
  AM_VALUE_OBJ_ID,
  /**
   * An object items variant.
   */
  AM_VALUE_OBJ_ITEMS,
  /**
   * A UTF-8 string variant.
   */
  AM_VALUE_STR,
  /**
   * A UTF-8 strings variant.
   */
  AM_VALUE_STRS,
  /**
   * A synchronization message variant.
   */
  AM_VALUE_SYNC_MESSAGE,
  /**
   * A synchronization state variant.
   */
  AM_VALUE_SYNC_STATE,
  /**
   * A Lamport timestamp variant.
   */
  AM_VALUE_TIMESTAMP,
  /**
   * A 64-bit unsigned integer variant.
   */
  AM_VALUE_UINT,
  /**
   * An unknown type of scalar value variant.
   */
  AM_VALUE_UNKNOWN,
};
typedef uint8_t AMvalueVariant;

typedef union AMvalue {
  AMvalueVariant tag;
  struct {
    AMvalueVariant actor_id_tag;
    const struct AMactorId *actor_id;
  };
  struct {
    AMvalueVariant boolean_tag;
    bool boolean;
  };
  struct {
    AMvalueVariant bytes_tag;
    struct AMbyteSpan bytes;
  };
  struct {
    AMvalueVariant change_hashes_tag;
    struct AMchangeHashes change_hashes;
  };
  struct {
    AMvalueVariant changes_tag;
    struct AMchanges changes;
  };
  struct {
    AMvalueVariant counter_tag;
    int64_t counter;
  };
  struct {
    AMvalueVariant doc_tag;
    struct AMdoc *doc;
  };
  struct {
    AMvalueVariant f64_tag;
    double f64;
  };
  struct {
    AMvalueVariant int_tag;
    int64_t int_;
  };
  struct {
    AMvalueVariant list_items_tag;
    struct AMlistItems list_items;
  };
  struct {
    AMvalueVariant map_items_tag;
    struct AMmapItems map_items;
  };
  struct {
    AMvalueVariant obj_id_tag;
    const struct AMobjId *obj_id;
  };
  struct {
    AMvalueVariant obj_items_tag;
    struct AMobjItems obj_items;
  };
  struct {
    AMvalueVariant str_tag;
    const char *str;
  };
  struct {
    AMvalueVariant strs_tag;
    struct AMstrs strs;
  };
  struct {
    AMvalueVariant sync_message_tag;
    const struct AMsyncMessage *sync_message;
  };
  struct {
    AMvalueVariant sync_state_tag;
    struct AMsyncState *sync_state;
  };
  struct {
    AMvalueVariant timestamp_tag;
    int64_t timestamp;
  };
  struct {
    AMvalueVariant uint_tag;
    uint64_t uint;
  };
  struct {
    AMvalueVariant unknown_tag;
    struct AMunknownValue unknown;
  };
} AMvalue;

/**
 * \struct AMresultStack
 * \installed_headerfile
 * \brief A node in a singly-linked list of result pointers.
 *
 * \note Using this data structure is purely optional because its only purpose
 *       is to make memory management tolerable for direct usage of this API
 *       in C, C++ and Objective-C.
 */
typedef struct AMresultStack {
  /**
   * A result to be deallocated.
   */
  struct AMresult *result;
  /**
   * The next node in the singly-linked list or `NULL`.
   */
  struct AMresultStack *next;
} AMresultStack;

/**
 * \memberof AMresultStack
 * \brief The prototype of a function to be called when a value matching the
 *        given discriminant cannot be extracted from the result at the top of
 *        the given stack.
 *
 * \note Implementing this function is purely optional because its only purpose
 *       is to make memory management tolerable for direct usage of this API
 *       in C, C++ and Objective-C.
 */
typedef void (*AMpushCallback)(struct AMresultStack **stack, uint8_t discriminant);

/**
 * \struct AMsyncHaves
 * \installed_headerfile
 * \brief A random-access iterator over a sequence of synchronization haves.
 */
typedef struct AMsyncHaves {
  /**
   * An implementation detail that is intentionally opaque.
   * \warning Modifying \p detail will cause undefined behavior.
   * \note The actual size of \p detail will vary by platform, this is just
   *       the one for the platform this documentation was built on.
   */
  uint8_t detail[+8+8+8+8];
} AMsyncHaves;

/**
 * \memberof AMactorId
 * \brief Gets the value of an actor identifier as a sequence of bytes.
 *
 * \param[in] actor_id A pointer to an `AMactorId` struct.
 * \pre \p actor_id `!= NULL`.
 * \return An `AMbyteSpan` struct.
 * \internal
 *
 * # Safety
 * actor_id must be a valid pointer to an AMactorId
 */
struct AMbyteSpan AMactorIdBytes(const struct AMactorId *actor_id);

/**
 * \memberof AMactorId
 * \brief Compares two actor identifiers.
 *
 * \param[in] actor_id1 A pointer to an `AMactorId` struct.
 * \param[in] actor_id2 A pointer to an `AMactorId` struct.
 * \return `-1` if \p actor_id1 `<` \p actor_id2, `0` if
 *         \p actor_id1 `==` \p actor_id2 and `1` if
 *         \p actor_id1 `>` \p actor_id2.
 * \pre \p actor_id1 `!= NULL`.
 * \pre \p actor_id2 `!= NULL`.
 * \internal
 *
 * #Safety
 * actor_id1 must be a valid pointer to an AMactorId
 * actor_id2 must be a valid pointer to an AMactorId
 */
ptrdiff_t AMactorIdCmp(const struct AMactorId *actor_id1, const struct AMactorId *actor_id2);

/**
 * \memberof AMactorId
 * \brief Allocates a new actor identifier and initializes it with a random
 *        UUID.
 *
 * \return A pointer to an `AMresult` struct containing a pointer to an
 *         `AMactorId` struct.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 */
struct AMresult *AMactorIdInit(void);

/**
 * \memberof AMactorId
 * \brief Allocates a new actor identifier and initializes it from a sequence
 *        of bytes.
 *
 * \param[in] src A pointer to a contiguous sequence of bytes.
 * \param[in] count The number of bytes to copy from \p src.
 * \pre `0 <` \p count `<= sizeof(`\p src`)`.
 * \return A pointer to an `AMresult` struct containing a pointer to an
 *         `AMactorId` struct.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * src must be a byte array of size `>= count`
 */
struct AMresult *AMactorIdInitBytes(const uint8_t *src, size_t count);

/**
 * \memberof AMactorId
 * \brief Allocates a new actor identifier and initializes it from a
 *        hexadecimal string.
 *
 * \param[in] hex_str A UTF-8 string.
 * \return A pointer to an `AMresult` struct containing a pointer to an
 *         `AMactorId` struct.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * hex_str must be a null-terminated array of `c_char`
 */
struct AMresult *AMactorIdInitStr(const char *hex_str);

/**
 * \memberof AMactorId
 * \brief Gets the value of an actor identifier as a hexadecimal string.
 *
 * \param[in] actor_id A pointer to an `AMactorId` struct.
 * \pre \p actor_id `!= NULL`.
 * \return A UTF-8 string.
 * \internal
 *
 * # Safety
 * actor_id must be a valid pointer to an AMactorId
 */
const char *AMactorIdStr(const struct AMactorId *actor_id);

/**
 * \memberof AMchange
 * \brief Gets the first referenced actor identifier in a change.
 *
 * \param[in] change A pointer to an `AMchange` struct.
 * \pre \p change `!= NULL`.
 * \return A pointer to an `AMresult` struct containing a pointer to an
 *         `AMactorId` struct.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * change must be a valid pointer to an AMchange
 */
struct AMresult *AMchangeActorId(const struct AMchange *change);

/**
 * \memberof AMchange
 * \brief Compresses the raw bytes of a change.
 *
 * \param[in,out] change A pointer to an `AMchange` struct.
 * \pre \p change `!= NULL`.
 * \internal
 *
 * # Safety
 * change must be a valid pointer to an AMchange
 */
void AMchangeCompress(struct AMchange *change);

/**
 * \memberof AMchange
 * \brief Gets the dependencies of a change.
 *
 * \param[in] change A pointer to an `AMchange` struct.
 * \return A pointer to an `AMchangeHashes` struct or `NULL`.
 * \pre \p change `!= NULL`.
 * \internal
 *
 * # Safety
 * change must be a valid pointer to an AMchange
 */
struct AMchangeHashes AMchangeDeps(const struct AMchange *change);

/**
 * \memberof AMchange
 * \brief Gets the extra bytes of a change.
 *
 * \param[in] change A pointer to an `AMchange` struct.
 * \return An `AMbyteSpan` struct.
 * \pre \p change `!= NULL`.
 * \internal
 *
 * # Safety
 * change must be a valid pointer to an AMchange
 */
struct AMbyteSpan AMchangeExtraBytes(const struct AMchange *change);

/**
 * \memberof AMchange
 * \brief Loads a sequence of bytes into a change.
 *
 * \param[in] src A pointer to an array of bytes.
 * \param[in] count The number of bytes in \p src to load.
 * \return A pointer to an `AMresult` struct containing an `AMchange` struct.
 * \pre \p src `!= NULL`.
 * \pre `0 <` \p count `<= sizeof(`\p src`)`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * src must be a byte array of size `>= count`
 */
struct AMresult *AMchangeFromBytes(const uint8_t *src, size_t count);

/**
 * \memberof AMchange
 * \brief Gets the hash of a change.
 *
 * \param[in] change A pointer to an `AMchange` struct.
 * \return A change hash as an `AMbyteSpan` struct.
 * \pre \p change `!= NULL`.
 * \internal
 *
 * # Safety
 * change must be a valid pointer to an AMchange
 */
struct AMbyteSpan AMchangeHash(const struct AMchange *change);

/**
 * \memberof AMchange
 * \brief Tests the emptiness of a change.
 *
 * \param[in] change A pointer to an `AMchange` struct.
 * \return A boolean.
 * \pre \p change `!= NULL`.
 * \internal
 *
 * # Safety
 * change must be a valid pointer to an AMchange
 */
bool AMchangeIsEmpty(const struct AMchange *change);

/**
 * \memberof AMchange
 * \brief Gets the maximum operation index of a change.
 *
 * \param[in] change A pointer to an `AMchange` struct.
 * \return A 64-bit unsigned integer.
 * \pre \p change `!= NULL`.
 * \internal
 *
 * # Safety
 * change must be a valid pointer to an AMchange
 */
uint64_t AMchangeMaxOp(const struct AMchange *change);

/**
 * \memberof AMchange
 * \brief Gets the message of a change.
 *
 * \param[in] change A pointer to an `AMchange` struct.
 * \return A UTF-8 string or `NULL`.
 * \pre \p change `!= NULL`.
 * \internal
 *
 * # Safety
 * change must be a valid pointer to an AMchange
 */
const char *AMchangeMessage(const struct AMchange *change);

/**
 * \memberof AMchange
 * \brief Gets the index of a change in the changes from an actor.
 *
 * \param[in] change A pointer to an `AMchange` struct.
 * \return A 64-bit unsigned integer.
 * \pre \p change `!= NULL`.
 * \internal
 *
 * # Safety
 * change must be a valid pointer to an AMchange
 */
uint64_t AMchangeSeq(const struct AMchange *change);

/**
 * \memberof AMchange
 * \brief Gets the size of a change.
 *
 * \param[in] change A pointer to an `AMchange` struct.
 * \return A 64-bit unsigned integer.
 * \pre \p change `!= NULL`.
 * \internal
 *
 * # Safety
 * change must be a valid pointer to an AMchange
 */
size_t AMchangeSize(const struct AMchange *change);

/**
 * \memberof AMchange
 * \brief Gets the start operation index of a change.
 *
 * \param[in] change A pointer to an `AMchange` struct.
 * \return A 64-bit unsigned integer.
 * \pre \p change `!= NULL`.
 * \internal
 *
 * # Safety
 * change must be a valid pointer to an AMchange
 */
uint64_t AMchangeStartOp(const struct AMchange *change);

/**
 * \memberof AMchange
 * \brief Gets the commit time of a change.
 *
 * \param[in] change A pointer to an `AMchange` struct.
 * \return A 64-bit signed integer.
 * \pre \p change `!= NULL`.
 * \internal
 *
 * # Safety
 * change must be a valid pointer to an AMchange
 */
int64_t AMchangeTime(const struct AMchange *change);

/**
 * \memberof AMchange
 * \brief Gets the raw bytes of a change.
 *
 * \param[in] change A pointer to an `AMchange` struct.
 * \return An `AMbyteSpan` struct.
 * \pre \p change `!= NULL`.
 * \internal
 *
 * # Safety
 * change must be a valid pointer to an AMchange
 */
struct AMbyteSpan AMchangeRawBytes(const struct AMchange *change);

/**
 * \memberof AMchange
 * \brief Loads a document into a sequence of changes.
 *
 * \param[in] src A pointer to an array of bytes.
 * \param[in] count The number of bytes in \p src to load.
 * \return A pointer to an `AMresult` struct containing a sequence of
 *         `AMchange` structs.
 * \pre \p src `!= NULL`.
 * \pre `0 <` \p count `<= sizeof(`\p src`)`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * src must be a byte array of size `>= count`
 */
struct AMresult *AMchangeLoadDocument(const uint8_t *src, size_t count);

/**
 * \memberof AMchangeHashes
 * \brief Advances an iterator over a sequence of change hashes by at most
 *        \p |n| positions where the sign of \p n is relative to the
 *        iterator's direction.
 *
 * \param[in,out] change_hashes A pointer to an `AMchangeHashes` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \pre \p change_hashes `!= NULL`.
 * \internal
 *
 * #Safety
 * change_hashes must be a valid pointer to an AMchangeHashes
 */
void AMchangeHashesAdvance(struct AMchangeHashes *change_hashes, ptrdiff_t n);

/**
 * \memberof AMchangeHashes
 * \brief Compares the sequences of change hashes underlying a pair of
 *        iterators.
 *
 * \param[in] change_hashes1 A pointer to an `AMchangeHashes` struct.
 * \param[in] change_hashes2 A pointer to an `AMchangeHashes` struct.
 * \return `-1` if \p change_hashes1 `<` \p change_hashes2, `0` if
 *         \p change_hashes1 `==` \p change_hashes2 and `1` if
 *         \p change_hashes1 `>` \p change_hashes2.
 * \pre \p change_hashes1 `!= NULL`.
 * \pre \p change_hashes2 `!= NULL`.
 * \internal
 *
 * #Safety
 * change_hashes1 must be a valid pointer to an AMchangeHashes
 * change_hashes2 must be a valid pointer to an AMchangeHashes
 */
ptrdiff_t AMchangeHashesCmp(const struct AMchangeHashes *change_hashes1, const struct AMchangeHashes *change_hashes2);

/**
 * \memberof AMchangeHashes
 * \brief Allocates an iterator over a sequence of change hashes and
 *        initializes it from a sequence of byte spans.
 *
 * \param[in] src A pointer to an array of `AMbyteSpan` structs.
 * \param[in] count The number of `AMbyteSpan` structs to copy from \p src.
 * \return A pointer to an `AMresult` struct containing an `AMchangeHashes`
 *         struct.
 * \pre \p src `!= NULL`.
 * \pre `0 <` \p count `<= sizeof(`\p src`) / sizeof(AMbyteSpan)`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * src must be an AMbyteSpan array of size `>= count`
 */
struct AMresult *AMchangeHashesInit(const struct AMbyteSpan *src, size_t count);

/**
 * \memberof AMchangeHashes
 * \brief Gets the change hash at the current position of an iterator over a
 *        sequence of change hashes and then advances it by at most \p |n|
 *        positions where the sign of \p n is relative to the iterator's
 *        direction.
 *
 * \param[in,out] change_hashes A pointer to an `AMchangeHashes` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \return An `AMbyteSpan` struct with `.src == NULL` when \p change_hashes
 *         was previously advanced past its forward/reverse limit.
 * \pre \p change_hashes `!= NULL`.
 * \internal
 *
 * #Safety
 * change_hashes must be a valid pointer to an AMchangeHashes
 */
struct AMbyteSpan AMchangeHashesNext(struct AMchangeHashes *change_hashes, ptrdiff_t n);

/**
 * \memberof AMchangeHashes
 * \brief Advances an iterator over a sequence of change hashes by at most
 *        \p |n| positions where the sign of \p n is relative to the
 *        iterator's direction and then gets the change hash at its new
 *        position.
 *
 * \param[in,out] change_hashes A pointer to an `AMchangeHashes` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \return An `AMbyteSpan` struct with `.src == NULL` when \p change_hashes is
 *         presently advanced past its forward/reverse limit.
 * \pre \p change_hashes `!= NULL`.
 * \internal
 *
 * #Safety
 * change_hashes must be a valid pointer to an AMchangeHashes
 */
struct AMbyteSpan AMchangeHashesPrev(struct AMchangeHashes *change_hashes, ptrdiff_t n);

/**
 * \memberof AMchangeHashes
 * \brief Gets the size of the sequence of change hashes underlying an
 *        iterator.
 *
 * \param[in] change_hashes A pointer to an `AMchangeHashes` struct.
 * \return The count of values in \p change_hashes.
 * \pre \p change_hashes `!= NULL`.
 * \internal
 *
 * #Safety
 * change_hashes must be a valid pointer to an AMchangeHashes
 */
size_t AMchangeHashesSize(const struct AMchangeHashes *change_hashes);

/**
 * \memberof AMchangeHashes
 * \brief Creates an iterator over the same sequence of change hashes as the
 *        given one but with the opposite position and direction.
 *
 * \param[in] change_hashes A pointer to an `AMchangeHashes` struct.
 * \return An `AMchangeHashes` struct
 * \pre \p change_hashes `!= NULL`.
 * \internal
 *
 * #Safety
 * change_hashes must be a valid pointer to an AMchangeHashes
 */
struct AMchangeHashes AMchangeHashesReversed(const struct AMchangeHashes *change_hashes);

/**
 * \memberof AMchangeHashes
 * \brief Creates an iterator at the starting position over the same sequence
 *        of change hashes as the given one.
 *
 * \param[in] change_hashes A pointer to an `AMchangeHashes` struct.
 * \return An `AMchangeHashes` struct
 * \pre \p change_hashes `!= NULL`.
 * \internal
 *
 * #Safety
 * change_hashes must be a valid pointer to an AMchangeHashes
 */
struct AMchangeHashes AMchangeHashesRewound(const struct AMchangeHashes *change_hashes);

/**
 * \memberof AMchanges
 * \brief Advances an iterator over a sequence of changes by at most \p |n|
 *        positions where the sign of \p n is relative to the iterator's
 *        direction.
 *
 * \param[in,out] changes A pointer to an `AMchanges` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \pre \p changes `!= NULL`.
 * \internal
 *
 * #Safety
 * changes must be a valid pointer to an AMchanges
 */
void AMchangesAdvance(struct AMchanges *changes, ptrdiff_t n);

/**
 * \memberof AMchanges
 * \brief Tests the equality of two sequences of changes underlying a pair of
 *        iterators.
 *
 * \param[in] changes1 A pointer to an `AMchanges` struct.
 * \param[in] changes2 A pointer to an `AMchanges` struct.
 * \return `true` if \p changes1 `==` \p changes2 and `false` otherwise.
 * \pre \p changes1 `!= NULL`.
 * \pre \p changes2 `!= NULL`.
 * \internal
 *
 * #Safety
 * changes1 must be a valid pointer to an AMchanges
 * changes2 must be a valid pointer to an AMchanges
 */
bool AMchangesEqual(const struct AMchanges *changes1, const struct AMchanges *changes2);

/**
 * \memberof AMchanges
 * \brief Allocates an iterator over a sequence of changes and initializes it
 *        from a sequence of byte spans.
 *
 * \param[in] src A pointer to an array of `AMbyteSpan` structs.
 * \param[in] count The number of `AMbyteSpan` structs to copy from \p src.
 * \return A pointer to an `AMresult` struct containing an `AMchanges` struct.
 * \pre \p src `!= NULL`.
 * \pre `0 <` \p count `<= sizeof(`\p src`) / sizeof(AMbyteSpan)`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * src must be an AMbyteSpan array of size `>= count`
 */
struct AMresult *AMchangesInit(const struct AMbyteSpan *src, size_t count);

/**
 * \memberof AMchanges
 * \brief Gets the change at the current position of an iterator over a
 *        sequence of changes and then advances it by at most \p |n| positions
 *        where the sign of \p n is relative to the iterator's direction.
 *
 * \param[in,out] changes A pointer to an `AMchanges` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \return A pointer to an `AMchange` struct that's `NULL` when \p changes was
 *         previously advanced past its forward/reverse limit.
 * \pre \p changes `!= NULL`.
 * \internal
 *
 * #Safety
 * changes must be a valid pointer to an AMchanges
 */
const struct AMchange *AMchangesNext(struct AMchanges *changes, ptrdiff_t n);

/**
 * \memberof AMchanges
 * \brief Advances an iterator over a sequence of changes by at most \p |n|
 *        positions where the sign of \p n is relative to the iterator's
 *        direction and then gets the change at its new position.
 *
 * \param[in,out] changes A pointer to an `AMchanges` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \return A pointer to an `AMchange` struct that's `NULL` when \p changes is
 *         presently advanced past its forward/reverse limit.
 * \pre \p changes `!= NULL`.
 * \internal
 *
 * #Safety
 * changes must be a valid pointer to an AMchanges
 */
const struct AMchange *AMchangesPrev(struct AMchanges *changes, ptrdiff_t n);

/**
 * \memberof AMchanges
 * \brief Gets the size of the sequence of changes underlying an iterator.
 *
 * \param[in] changes A pointer to an `AMchanges` struct.
 * \return The count of values in \p changes.
 * \pre \p changes `!= NULL`.
 * \internal
 *
 * #Safety
 * changes must be a valid pointer to an AMchanges
 */
size_t AMchangesSize(const struct AMchanges *changes);

/**
 * \memberof AMchanges
 * \brief Creates an iterator over the same sequence of changes as the given
 *        one but with the opposite position and direction.
 *
 * \param[in] changes A pointer to an `AMchanges` struct.
 * \return An `AMchanges` struct.
 * \pre \p changes `!= NULL`.
 * \internal
 *
 * #Safety
 * changes must be a valid pointer to an AMchanges
 */
struct AMchanges AMchangesReversed(const struct AMchanges *changes);

/**
 * \memberof AMchanges
 * \brief Creates an iterator at the starting position over the same sequence
 *        of changes as the given one.
 *
 * \param[in] changes A pointer to an `AMchanges` struct.
 * \return An `AMchanges` struct
 * \pre \p changes `!= NULL`.
 * \internal
 *
 * #Safety
 * changes must be a valid pointer to an AMchanges
 */
struct AMchanges AMchangesRewound(const struct AMchanges *changes);

/**
 * \memberof AMdoc
 * \brief Applies a sequence of changes to a document.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] changes A pointer to an `AMchanges` struct.
 * \pre \p doc `!= NULL`.
 * \pre \p changes `!= NULL`.
 * \return A pointer to an `AMresult` struct containing a void.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * changes must be a valid pointer to an AMchanges.
 */
struct AMresult *AMapplyChanges(struct AMdoc *doc, const struct AMchanges *changes);

/**
 * \memberof AMdoc
 * \brief Allocates storage for a document and initializes it by duplicating
 *        the given document.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \return A pointer to an `AMresult` struct containing a pointer to an
 *         `AMdoc` struct.
 * \pre \p doc `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 */
struct AMresult *AMclone(const struct AMdoc *doc);

/**
 * \memberof AMdoc
 * \brief Allocates a new document and initializes it with defaults.
 *
 * \param[in] actor_id A pointer to an `AMactorId` struct or `NULL` for a
 *                     random one.
 * \return A pointer to an `AMresult` struct containing a pointer to an
 *         `AMdoc` struct.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 *
 * # Safety
 * actor_id must be a valid pointer to an AMactorId or std::ptr::null()
 */
struct AMresult *AMcreate(const struct AMactorId *actor_id);

/**
 * \memberof AMdoc
 * \brief Commits the current operations on a document with an optional
 *        message and/or time override as seconds since the epoch.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] message A UTF-8 string or `NULL`.
 * \param[in] time A pointer to a `time_t` value or `NULL`.
 * \return A pointer to an `AMresult` struct containing an `AMchangeHashes`
 *         with one element.
 * \pre \p doc `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 */
struct AMresult *AMcommit(struct AMdoc *doc, const char *message, const time_t *time);

/**
 * \memberof AMdoc
 * \brief Tests the equality of two documents after closing their respective
 *        transactions.
 *
 * \param[in,out] doc1 An `AMdoc` struct.
 * \param[in,out] doc2 An `AMdoc` struct.
 * \return `true` if \p doc1 `==` \p doc2 and `false` otherwise.
 * \pre \p doc1 `!= NULL`.
 * \pre \p doc2 `!= NULL`.
 * \internal
 *
 * #Safety
 * doc1 must be a valid pointer to an AMdoc
 * doc2 must be a valid pointer to an AMdoc
 */
bool AMequal(struct AMdoc *doc1, struct AMdoc *doc2);

/**
 * \memberof AMdoc
 * \brief Forks this document at the current or a historical point for use by
 *        a different actor.
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] heads A pointer to an `AMchangeHashes` struct for a historical
 *                  point or `NULL` for the current point.
 * \return A pointer to an `AMresult` struct containing a pointer to an
 *         `AMdoc` struct.
 * \pre \p doc `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * heads must be a valid pointer to an AMchangeHashes or std::ptr::null()
 */
struct AMresult *AMfork(struct AMdoc *doc, const struct AMchangeHashes *heads);

/**
 * \memberof AMdoc
 * \brief Generates a synchronization message for a peer based upon the given
 *        synchronization state.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in,out] sync_state A pointer to an `AMsyncState` struct.
 * \return A pointer to an `AMresult` struct containing either a pointer to an
 *         `AMsyncMessage` struct or a void.
 * \pre \p doc `!= NULL`.
 * \pre \p sync_state `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * sync_state must be a valid pointer to an AMsyncState
 */
struct AMresult *AMgenerateSyncMessage(struct AMdoc *doc, struct AMsyncState *sync_state);

/**
 * \memberof AMdoc
 * \brief Gets a document's actor identifier.
 *
 * \param[in] doc A pointer to an `AMdoc` struct.
 * \return A pointer to an `AMresult` struct containing a pointer to an
 *         `AMactorId` struct.
 * \pre \p doc `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 *
 * # Safety
 * doc must be a valid pointer to an AMdoc
 */
struct AMresult *AMgetActorId(const struct AMdoc *doc);

/**
 * \memberof AMdoc
 * \brief Gets the change added to a document by its respective hash.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] src A pointer to an array of bytes.
 * \param[in] count The number of bytes in \p src.
 * \return A pointer to an `AMresult` struct containing an `AMchanges` struct.
 * \pre \p doc `!= NULL`.
 * \pre \p src `!= NULL`.
 * \pre \p count `>= AM_CHANGE_HASH_SIZE`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * src must be a byte array of size `>= automerge::types::HASH_SIZE`
 */
struct AMresult *AMgetChangeByHash(struct AMdoc *doc, const uint8_t *src, size_t count);

/**
 * \memberof AMdoc
 * \brief Gets the changes added to a document by their respective hashes.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] have_deps A pointer to an `AMchangeHashes` struct or `NULL`.
 * \return A pointer to an `AMresult` struct containing an `AMchanges` struct.
 * \pre \p doc `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 */
struct AMresult *AMgetChanges(struct AMdoc *doc, const struct AMchangeHashes *have_deps);

/**
 * \memberof AMdoc
 * \brief Gets the changes added to a second document that weren't added to
 *        a first document.
 *
 * \param[in,out] doc1 An `AMdoc` struct.
 * \param[in,out] doc2 An `AMdoc` struct.
 * \return A pointer to an `AMresult` struct containing an `AMchanges` struct.
 * \pre \p doc1 `!= NULL`.
 * \pre \p doc2 `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc1 must be a valid pointer to an AMdoc
 * doc2 must be a valid pointer to an AMdoc
 */
struct AMresult *AMgetChangesAdded(struct AMdoc *doc1, struct AMdoc *doc2);

/**
 * \memberof AMdoc
 * \brief Gets the current heads of a document.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \return A pointer to an `AMresult` struct containing an `AMchangeHashes`
 *         struct.
 * \pre \p doc `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 */
struct AMresult *AMgetHeads(struct AMdoc *doc);

/**
 * \memberof AMdoc
 * \brief Gets the hashes of the changes in a document that aren't transitive
 *        dependencies of the given hashes of changes.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] heads A pointer to an `AMchangeHashes` struct or `NULL`.
 * \return A pointer to an `AMresult` struct containing an `AMchangeHashes`
 *         struct.
 * \pre \p doc `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * heads must be a valid pointer to an AMchangeHashes or std::ptr::null()
 */
struct AMresult *AMgetMissingDeps(struct AMdoc *doc, const struct AMchangeHashes *heads);

/**
 * \memberof AMdoc
 * \brief Gets the last change made to a document.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \return A pointer to an `AMresult` struct containing either an `AMchange`
 *         struct or a void.
 * \pre \p doc `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 */
struct AMresult *AMgetLastLocalChange(struct AMdoc *doc);

/**
 * \memberof AMdoc
 * \brief Gets the current or historical keys of a map object.
 *
 * \param[in] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] heads A pointer to an `AMchangeHashes` struct for historical
 *                  keys or `NULL` for current keys.
 * \return A pointer to an `AMresult` struct containing an `AMstrs` struct.
 * \pre \p doc `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * heads must be a valid pointer to an AMchangeHashes or std::ptr::null()
 */
struct AMresult *AMkeys(const struct AMdoc *doc, const struct AMobjId *obj_id, const struct AMchangeHashes *heads);

/**
 * \memberof AMdoc
 * \brief Allocates storage for a document and initializes it with the compact
 *        form of an incremental save.
 *
 * \param[in] src A pointer to an array of bytes.
 * \param[in] count The number of bytes in \p src to load.
 * \return A pointer to an `AMresult` struct containing a pointer to an
 *         `AMdoc` struct.
 * \pre \p src `!= NULL`.
 * \pre `0 <` \p count `<= sizeof(`\p src`)`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * src must be a byte array of size `>= count`
 */
struct AMresult *AMload(const uint8_t *src, size_t count);

/**
 * \memberof AMdoc
 * \brief Loads the compact form of an incremental save into a document.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] src A pointer to an array of bytes.
 * \param[in] count The number of bytes in \p src to load.
 * \return A pointer to an `AMresult` struct containing the number of
 *         operations loaded from \p src.
 * \pre \p doc `!= NULL`.
 * \pre \p src `!= NULL`.
 * \pre `0 <` \p count `<= sizeof(`\p src`)`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * src must be a byte array of size `>= count`
 */
struct AMresult *AMloadIncremental(struct AMdoc *doc, const uint8_t *src, size_t count);

/**
 * \memberof AMdoc
 * \brief Applies all of the changes in \p src which are not in \p dest to
 *        \p dest.
 *
 * \param[in,out] dest A pointer to an `AMdoc` struct.
 * \param[in,out] src A pointer to an `AMdoc` struct.
 * \return A pointer to an `AMresult` struct containing an `AMchangeHashes`
 *         struct.
 * \pre \p dest `!= NULL`.
 * \pre \p src `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * dest must be a valid pointer to an AMdoc
 * src must be a valid pointer to an AMdoc
 */
struct AMresult *AMmerge(struct AMdoc *dest, struct AMdoc *src);

/**
 * \memberof AMdoc
 * \brief Gets the current or historical size of an object.
 *
 * \param[in] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] heads A pointer to an `AMchangeHashes` struct for historical
 *            size or `NULL` for current size.
 * \return A 64-bit unsigned integer.
 * \pre \p doc `!= NULL`.
 * \internal
 *
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * heads must be a valid pointer to an AMchangeHashes or std::ptr::null()
 */
size_t AMobjSize(const struct AMdoc *doc, const struct AMobjId *obj_id, const struct AMchangeHashes *heads);

/**
 * \memberof AMdoc
 * \brief Gets the current or historical values of an object within its entire
 *        range.
 *
 * \param[in] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] heads A pointer to an `AMchangeHashes` struct for historical
 *                  items or `NULL` for current items.
 * \return A pointer to an `AMresult` struct containing an `AMobjItems` struct.
 * \pre \p doc `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * heads must be a valid pointer to an AMchangeHashes or std::ptr::null()
 */
struct AMresult *AMobjValues(const struct AMdoc *doc, const struct AMobjId *obj_id, const struct AMchangeHashes *heads);

/**
 * \memberof AMdoc
 * \brief Gets the number of pending operations added during a document's
 *        current transaction.
 *
 * \param[in] doc A pointer to an `AMdoc` struct.
 * \return The count of pending operations for \p doc.
 * \pre \p doc `!= NULL`.
 * \internal
 *
 * # Safety
 * doc must be a valid pointer to an AMdoc
 */
size_t AMpendingOps(const struct AMdoc *doc);

/**
 * \memberof AMdoc
 * \brief Receives a synchronization message from a peer based upon a given
 *        synchronization state.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in,out] sync_state A pointer to an `AMsyncState` struct.
 * \param[in] sync_message A pointer to an `AMsyncMessage` struct.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre \p sync_state `!= NULL`.
 * \pre \p sync_message `!= NULL`.
 * \internal
 *
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * sync_state must be a valid pointer to an AMsyncState
 * sync_message must be a valid pointer to an AMsyncMessage
 */
struct AMresult *AMreceiveSyncMessage(struct AMdoc *doc, struct AMsyncState *sync_state, const struct AMsyncMessage *sync_message);

/**
 * \memberof AMdoc
 * \brief Cancels the pending operations added during a document's current
 *        transaction and gets the number of cancellations.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \return The count of pending operations for \p doc that were cancelled.
 * \pre \p doc `!= NULL`.
 * \internal
 *
 * # Safety
 * doc must be a valid pointer to an AMdoc
 */
size_t AMrollback(struct AMdoc *doc);

/**
 * \memberof AMdoc
 * \brief Saves the entirety of a document into a compact form.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \return A pointer to an `AMresult` struct containing an array of bytes as
 *         an `AMbyteSpan` struct.
 * \pre \p doc `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 */
struct AMresult *AMsave(struct AMdoc *doc);

/**
 * \memberof AMdoc
 * \brief Saves the changes to a document since its last save into a compact
 *        form.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \return A pointer to an `AMresult` struct containing an array of bytes as
 *         an `AMbyteSpan` struct.
 * \pre \p doc `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 */
struct AMresult *AMsaveIncremental(struct AMdoc *doc);

/**
 * \memberof AMdoc
 * \brief Puts the actor identifier of a document.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] actor_id A pointer to an `AMactorId` struct.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre \p actor_id `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * actor_id must be a valid pointer to an AMactorId
 */
struct AMresult *AMsetActorId(struct AMdoc *doc, const struct AMactorId *actor_id);

/**
 * \memberof AMdoc
 * \brief Splices values into and/or removes values from the identified object
 *        at a given position within it.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] pos A position in the object identified by \p obj_id or
 *                `SIZE_MAX` to indicate one past its end.
 * \param[in] del The number of characters to delete or `SIZE_MAX` to indicate
 *                all of them.
 * \param[in] src A pointer to an array of `AMvalue` structs.
 * \param[in] count The number of `AMvalue` structs in \p src to load.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre `0 <=` \p pos `<= AMobjSize(`\p obj_id`)` or \p pos `== SIZE_MAX`.
 * \pre `0 <=` \p del `<= AMobjSize(`\p obj_id`)` or \p del `== SIZE_MAX`.
 * \pre `(`\p src `!= NULL and 1 <=` \p count `<= sizeof(`\p src`)/
 *      sizeof(AMvalue)) or `\p src `== NULL or `\p count `== 0`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * src must be an AMvalue array of size `>= count` or std::ptr::null()
 */
struct AMresult *AMsplice(struct AMdoc *doc, const struct AMobjId *obj_id, size_t pos, size_t del, const union AMvalue *src, size_t count);

/**
 * \memberof AMdoc
 * \brief Splices characters into and/or removes characters from the
 *        identified object at a given position within it.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] pos A position in the text object identified by \p obj_id or
 *                `SIZE_MAX` to indicate one past its end.
 * \param[in] del The number of characters to delete or `SIZE_MAX` to indicate
 *                all of them.
 * \param[in] text A UTF-8 string.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre `0 <=` \p pos `<= AMobjSize(`\p obj_id`)` or \p pos `== SIZE_MAX`.
 * \pre `0 <=` \p del `<= AMobjSize(`\p obj_id`)` or \p del `== SIZE_MAX`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * text must be a null-terminated array of `c_char` or NULL.
 */
struct AMresult *AMspliceText(struct AMdoc *doc, const struct AMobjId *obj_id, size_t pos, size_t del, const char *text);

/**
 * \memberof AMdoc
 * \brief Gets the current or historical string represented by a text object.
 *
 * \param[in] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] heads A pointer to an `AMchangeHashes` struct for historical
 *                  keys or `NULL` for current keys.
 * \return A pointer to an `AMresult` struct containing a UTF-8 string.
 * \pre \p doc `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * heads must be a valid pointer to an AMchangeHashes or std::ptr::null()
 */
struct AMresult *AMtext(const struct AMdoc *doc, const struct AMobjId *obj_id, const struct AMchangeHashes *heads);

/**
 * \memberof AMdoc
 * \brief Deletes an index in a list object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] index An index in the list object identified by \p obj_id or
 *                  `SIZE_MAX` to indicate its last index.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre `0 <=` \p index `<= AMobjSize(`\p obj_id`)` or \p index `== SIZE_MAX`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 */
struct AMresult *AMlistDelete(struct AMdoc *doc, const struct AMobjId *obj_id, size_t index);

/**
 * \memberof AMdoc
 * \brief Gets the current or historical value at an index in a list object.
 *
 * \param[in] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] index An index in the list object identified by \p obj_id or
 *                  `SIZE_MAX` to indicate its last index.
 * \param[in] heads A pointer to an `AMchangeHashes` struct for a historical
 *                  value or `NULL` for the current value.
 * \return A pointer to an `AMresult` struct that doesn't contain a void.
 * \pre \p doc `!= NULL`.
 * \pre `0 <=` \p index `<= AMobjSize(`\p obj_id`)` or \p index `== SIZE_MAX`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * heads must be a valid pointer to an AMchangeHashes or std::ptr::null()
 */
struct AMresult *AMlistGet(const struct AMdoc *doc, const struct AMobjId *obj_id, size_t index, const struct AMchangeHashes *heads);

/**
 * \memberof AMdoc
 * \brief Gets all of the historical values at an index in a list object until
 *        its current one or a specific one.
 *
 * \param[in] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] index An index in the list object identified by \p obj_id or
 *                  `SIZE_MAX` to indicate its last index.
 * \param[in] heads A pointer to an `AMchangeHashes` struct for a historical
 *                  last value or `NULL` for the current last value.
 * \return A pointer to an `AMresult` struct containing an `AMobjItems` struct.
 * \pre \p doc `!= NULL`.
 * \pre `0 <=` \p index `<= AMobjSize(`\p obj_id`)` or \p index `== SIZE_MAX`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * heads must be a valid pointer to an AMchangeHashes or std::ptr::null()
 */
struct AMresult *AMlistGetAll(const struct AMdoc *doc, const struct AMobjId *obj_id, size_t index, const struct AMchangeHashes *heads);

/**
 * \memberof AMdoc
 * \brief Increments a counter at an index in a list object by the given
 *        value.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] index An index in the list object identified by \p obj_id or
 *                  `SIZE_MAX` to indicate its last index.
 * \param[in] value A 64-bit signed integer.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre `0 <=` \p index `<= AMobjSize(`\p obj_id`)` or \p index `== SIZE_MAX`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 */
struct AMresult *AMlistIncrement(struct AMdoc *doc, const struct AMobjId *obj_id, size_t index, int64_t value);

/**
 * \memberof AMdoc
 * \brief Puts a boolean as the value at an index in a list object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] index An index in the list object identified by \p obj_id or
 *                  `SIZE_MAX` to indicate its last index if \p insert
 *                  `== false` or one past its last index if \p insert
 *                  `== true`.
 * \param[in] insert A flag to insert \p value before \p index instead of
 *            writing \p value over \p index.
 * \param[in] value A boolean.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre `0 <=` \p index `<= AMobjSize(`\p obj_id`)` or \p index `== SIZE_MAX`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 */
struct AMresult *AMlistPutBool(struct AMdoc *doc, const struct AMobjId *obj_id, size_t index, bool insert, bool value);

/**
 * \memberof AMdoc
 * \brief Puts a sequence of bytes as the value at an index in a list object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] index An index in the list object identified by \p obj_id or
 *                  `SIZE_MAX` to indicate its last index if \p insert
 *                  `== false` or one past its last index if \p insert
 *                  `== true`.
 * \param[in] insert A flag to insert \p src before \p index instead of
 *            writing \p src over \p index.
 * \param[in] src A pointer to an array of bytes.
 * \param[in] count The number of bytes to copy from \p src.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre `0 <=` \p index `<= AMobjSize(`\p obj_id`)` or \p index `== SIZE_MAX`.
 * \pre \p src `!= NULL`.
 * \pre `0 <` \p count `<= sizeof(`\p src`)`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * src must be a byte array of size `>= count`
 */
struct AMresult *AMlistPutBytes(struct AMdoc *doc,
                                const struct AMobjId *obj_id,
                                size_t index,
                                bool insert,
                                const uint8_t *src,
                                size_t count);

/**
 * \memberof AMdoc
 * \brief Puts a CRDT counter as the value at an index in a list object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] index An index in the list object identified by \p obj_id or
 *                  `SIZE_MAX` to indicate its last index if \p insert
 *                  `== false` or one past its last index if \p insert
 *                  `== true`.
 * \param[in] insert A flag to insert \p value before \p index instead of
 *            writing \p value over \p index.
 * \param[in] value A 64-bit signed integer.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre `0 <=` \p index `<= AMobjSize(`\p obj_id`)` or \p index `== SIZE_MAX`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 */
struct AMresult *AMlistPutCounter(struct AMdoc *doc, const struct AMobjId *obj_id, size_t index, bool insert, int64_t value);

/**
 * \memberof AMdoc
 * \brief Puts a float as the value at an index in a list object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] index An index in the list object identified by \p obj_id or
 *                  `SIZE_MAX` to indicate its last index if \p insert
 *                  `== false` or one past its last index if \p insert
 *                  `== true`.
 * \param[in] insert A flag to insert \p value before \p index instead of
 *            writing \p value over \p index.
 * \param[in] value A 64-bit float.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre `0 <=` \p index `<= AMobjSize(`\p obj_id`)` or \p index `== SIZE_MAX`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 */
struct AMresult *AMlistPutF64(struct AMdoc *doc, const struct AMobjId *obj_id, size_t index, bool insert, double value);

/**
 * \memberof AMdoc
 * \brief Puts a signed integer as the value at an index in a list object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] index An index in the list object identified by \p obj_id or
 *                  `SIZE_MAX` to indicate its last index if \p insert
 *                  `== false` or one past its last index if \p insert
 *                  `== true`.
 * \param[in] insert A flag to insert \p value before \p index instead of
 *            writing \p value over \p index.
 * \param[in] value A 64-bit signed integer.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre `0 <=` \p index `<= AMobjSize(`\p obj_id`)` or \p index `== SIZE_MAX`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 */
struct AMresult *AMlistPutInt(struct AMdoc *doc, const struct AMobjId *obj_id, size_t index, bool insert, int64_t value);

/**
 * \memberof AMdoc
 * \brief Puts null as the value at an index in a list object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] index An index in the list object identified by \p obj_id or
 *                  `SIZE_MAX` to indicate its last index if \p insert
 *                  `== false` or one past its last index if \p insert
 *                  `== true`.
 * \param[in] insert A flag to insert \p value before \p index instead of
 *            writing \p value over \p index.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre `0 <=` \p index `<= AMobjSize(`\p obj_id`)` or \p index `== SIZE_MAX`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 */
struct AMresult *AMlistPutNull(struct AMdoc *doc, const struct AMobjId *obj_id, size_t index, bool insert);

/**
 * \memberof AMdoc
 * \brief Puts an empty object as the value at an index in a list object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] index An index in the list object identified by \p obj_id or
 *                  `SIZE_MAX` to indicate its last index if \p insert
 *                  `== false` or one past its last index if \p insert
 *                  `== true`.
 * \param[in] insert A flag to insert \p value before \p index instead of
 *                   writing \p value over \p index.
 * \param[in] obj_type An `AMobjIdType` enum tag.
 * \return A pointer to an `AMresult` struct containing a pointer to an
 *         `AMobjId` struct.
 * \pre \p doc `!= NULL`.
 * \pre `0 <=` \p index `<= AMobjSize(`\p obj_id`)` or \p index `== SIZE_MAX`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 */
struct AMresult *AMlistPutObject(struct AMdoc *doc, const struct AMobjId *obj_id, size_t index, bool insert, AMobjType obj_type);

/**
 * \memberof AMdoc
 * \brief Puts a UTF-8 string as the value at an index in a list object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] index An index in the list object identified by \p obj_id or
 *                  `SIZE_MAX` to indicate its last index if \p insert
 *                  `== false` or one past its last index if \p insert
 *                  `== true`.
 * \param[in] insert A flag to insert \p value before \p index instead of
 *            writing \p value over \p index.
 * \param[in] value A UTF-8 string.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre `0 <=` \p index `<= AMobjSize(`\p obj_id`)` or \p index `== SIZE_MAX`.
 * \pre \p value `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * value must be a null-terminated array of `c_char`
 */
struct AMresult *AMlistPutStr(struct AMdoc *doc, const struct AMobjId *obj_id, size_t index, bool insert, const char *value);

/**
 * \memberof AMdoc
 * \brief Puts a Lamport timestamp as the value at an index in a list object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] index An index in the list object identified by \p obj_id or
 *                  `SIZE_MAX` to indicate its last index if \p insert
 *                  `== false` or one past its last index if \p insert
 *                  `== true`.
 * \param[in] insert A flag to insert \p value before \p index instead of
 *            writing \p value over \p index.
 * \param[in] value A 64-bit signed integer.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre `0 <=` \p index `<= AMobjSize(`\p obj_id`)` or \p index `== SIZE_MAX`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 */
struct AMresult *AMlistPutTimestamp(struct AMdoc *doc, const struct AMobjId *obj_id, size_t index, bool insert, int64_t value);

/**
 * \memberof AMdoc
 * \brief Puts an unsigned integer as the value at an index in a list object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] index An index in the list object identified by \p obj_id or
 *                  `SIZE_MAX` to indicate its last index if \p insert
 *                  `== false` or one past its last index if \p insert
 *                  `== true`.
 * \param[in] insert A flag to insert \p value before \p index instead of
 *            writing \p value over \p index.
 * \param[in] value A 64-bit unsigned integer.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre `0 <=` \p index `<= AMobjSize(`\p obj_id`)` or \p index `== SIZE_MAX`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 */
struct AMresult *AMlistPutUint(struct AMdoc *doc, const struct AMobjId *obj_id, size_t index, bool insert, uint64_t value);

/**
 * \memberof AMdoc
 * \brief Gets the current or historical indices and values of the list object
 *        within the given range.
 *
 * \param[in] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] begin The first index in a range of indices.
 * \param[in] end At least one past the last index in a range of indices.
 * \param[in] heads A pointer to an `AMchangeHashes` struct for historical
 *                  indices and values or `NULL` for current indices and
 *                  values.
 * \return A pointer to an `AMresult` struct containing an `AMlistItems`
 *         struct.
 * \pre \p doc `!= NULL`.
 * \pre \p begin `<=` \p end `<= SIZE_MAX`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * heads must be a valid pointer to an AMchangeHashes or std::ptr::null()
 */
struct AMresult *AMlistRange(const struct AMdoc *doc,
                             const struct AMobjId *obj_id,
                             size_t begin,
                             size_t end,
                             const struct AMchangeHashes *heads);

/**
 * \memberof AMlistItem
 * \brief Gets the index of an item in a list object.
 *
 * \param[in] list_item A pointer to an `AMlistItem` struct.
 * \return A 64-bit unsigned integer.
 * \pre \p list_item `!= NULL`.
 * \internal
 *
 * # Safety
 * list_item must be a valid pointer to an AMlistItem
 */
size_t AMlistItemIndex(const struct AMlistItem *list_item);

/**
 * \memberof AMlistItem
 * \brief Gets the object identifier of an item in a list object.
 *
 * \param[in] list_item A pointer to an `AMlistItem` struct.
 * \return A pointer to an `AMobjId` struct.
 * \pre \p list_item `!= NULL`.
 * \internal
 *
 * # Safety
 * list_item must be a valid pointer to an AMlistItem
 */
const struct AMobjId *AMlistItemObjId(const struct AMlistItem *list_item);

/**
 * \memberof AMlistItem
 * \brief Gets the value of an item in a list object.
 *
 * \param[in] list_item A pointer to an `AMlistItem` struct.
 * \return An `AMvalue` struct.
 * \pre \p list_item `!= NULL`.
 * \internal
 *
 * # Safety
 * list_item must be a valid pointer to an AMlistItem
 */
union AMvalue AMlistItemValue(const struct AMlistItem *list_item);

/**
 * \memberof AMlistItems
 * \brief Advances an iterator over a sequence of list object items by at most
 *        \p |n| positions where the sign of \p n is relative to the
 *        iterator's direction.
 *
 * \param[in,out] list_items A pointer to an `AMlistItems` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \pre \p list_items `!= NULL`.
 * \internal
 *
 * #Safety
 * list_items must be a valid pointer to an AMlistItems
 */
void AMlistItemsAdvance(struct AMlistItems *list_items, ptrdiff_t n);

/**
 * \memberof AMlistItems
 * \brief Tests the equality of two sequences of list object items underlying
 *        a pair of iterators.
 *
 * \param[in] list_items1 A pointer to an `AMlistItems` struct.
 * \param[in] list_items2 A pointer to an `AMlistItems` struct.
 * \return `true` if \p list_items1 `==` \p list_items2 and `false` otherwise.
 * \pre \p list_items1 `!= NULL`.
 * \pre \p list_items2 `!= NULL`.
 * \internal
 *
 * #Safety
 * list_items1 must be a valid pointer to an AMlistItems
 * list_items2 must be a valid pointer to an AMlistItems
 */
bool AMlistItemsEqual(const struct AMlistItems *list_items1, const struct AMlistItems *list_items2);

/**
 * \memberof AMlistItems
 * \brief Gets the list object item at the current position of an iterator
 *        over a sequence of list object items and then advances it by at most
 *        \p |n| positions where the sign of \p n is relative to the
 *        iterator's direction.
 *
 * \param[in,out] list_items A pointer to an `AMlistItems` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \return A pointer to an `AMlistItem` struct that's `NULL` when
 *         \p list_items was previously advanced past its forward/reverse
 *         limit.
 * \pre \p list_items `!= NULL`.
 * \internal
 *
 * #Safety
 * list_items must be a valid pointer to an AMlistItems
 */
const struct AMlistItem *AMlistItemsNext(struct AMlistItems *list_items, ptrdiff_t n);

/**
 * \memberof AMlistItems
 * \brief Advances an iterator over a sequence of list object items by at most
 *        \p |n| positions where the sign of \p n is relative to the
 *        iterator's direction and then gets the list object item at its new
 *        position.
 *
 * \param[in,out] list_items A pointer to an `AMlistItems` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \return A pointer to an `AMlistItem` struct that's `NULL` when
 *         \p list_items is presently advanced past its forward/reverse limit.
 * \pre \p list_items `!= NULL`.
 * \internal
 *
 * #Safety
 * list_items must be a valid pointer to an AMlistItems
 */
const struct AMlistItem *AMlistItemsPrev(struct AMlistItems *list_items, ptrdiff_t n);

/**
 * \memberof AMlistItems
 * \brief Gets the size of the sequence of list object items underlying an
 *        iterator.
 *
 * \param[in] list_items A pointer to an `AMlistItems` struct.
 * \return The count of values in \p list_items.
 * \pre \p list_items `!= NULL`.
 * \internal
 *
 * #Safety
 * list_items must be a valid pointer to an AMlistItems
 */
size_t AMlistItemsSize(const struct AMlistItems *list_items);

/**
 * \memberof AMlistItems
 * \brief Creates an iterator over the same sequence of list object items as
 *        the given one but with the opposite position and direction.
 *
 * \param[in] list_items A pointer to an `AMlistItems` struct.
 * \return An `AMlistItems` struct
 * \pre \p list_items `!= NULL`.
 * \internal
 *
 * #Safety
 * list_items must be a valid pointer to an AMlistItems
 */
struct AMlistItems AMlistItemsReversed(const struct AMlistItems *list_items);

/**
 * \memberof AMlistItems
 * \brief Creates an iterator at the starting position over the same sequence
 *        of list object items as the given one.
 *
 * \param[in] list_items A pointer to an `AMlistItems` struct.
 * \return An `AMlistItems` struct
 * \pre \p list_items `!= NULL`.
 * \internal
 *
 * #Safety
 * list_items must be a valid pointer to an AMlistItems
 */
struct AMlistItems AMlistItemsRewound(const struct AMlistItems *list_items);

/**
 * \memberof AMdoc
 * \brief Deletes a key in a map object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] key A UTF-8 string key for the map object identified by \p obj_id.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre \p key `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * key must be a c string of the map key to be used
 */
struct AMresult *AMmapDelete(struct AMdoc *doc, const struct AMobjId *obj_id, const char *key);

/**
 * \memberof AMdoc
 * \brief Gets the current or historical value for a key in a map object.
 *
 * \param[in] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] key A UTF-8 string key for the map object identified by
 *                \p obj_id.
 * \param[in] heads A pointer to an `AMchangeHashes` struct for a historical
 *                  value or `NULL` for the current value.
 * \return A pointer to an `AMresult` struct that doesn't contain a void.
 * \pre \p doc `!= NULL`.
 * \pre \p key `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * key must be a c string of the map key to be used
 * heads must be a valid pointer to an AMchangeHashes or std::ptr::null()
 */
struct AMresult *AMmapGet(const struct AMdoc *doc, const struct AMobjId *obj_id, const char *key, const struct AMchangeHashes *heads);

/**
 * \memberof AMdoc
 * \brief Gets all of the historical values for a key in a map object until
 *        its current one or a specific one.
 *
 * \param[in] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] key A UTF-8 string key for the map object identified by
 *                \p obj_id.
 * \param[in] heads A pointer to an `AMchangeHashes` struct for a historical
 *                  last value or `NULL` for the current last value.
 * \return A pointer to an `AMresult` struct containing an `AMobjItems` struct.
 * \pre \p doc `!= NULL`.
 * \pre \p key `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * key must be a c string of the map key to be used
 * heads must be a valid pointer to an AMchangeHashes or std::ptr::null()
 */
struct AMresult *AMmapGetAll(const struct AMdoc *doc, const struct AMobjId *obj_id, const char *key, const struct AMchangeHashes *heads);

/**
 * \memberof AMdoc
 * \brief Increments a counter for a key in a map object by the given value.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] key A UTF-8 string key for the map object identified by \p obj_id.
 * \param[in] value A 64-bit signed integer.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre \p key `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * key must be a c string of the map key to be used
 */
struct AMresult *AMmapIncrement(struct AMdoc *doc, const struct AMobjId *obj_id, const char *key, int64_t value);

/**
 * \memberof AMdoc
 * \brief Puts a boolean as the value of a key in a map object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] key A UTF-8 string key for the map object identified by \p obj_id.
 * \param[in] value A boolean.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre \p key `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * key must be a c string of the map key to be used
 */
struct AMresult *AMmapPutBool(struct AMdoc *doc, const struct AMobjId *obj_id, const char *key, bool value);

/**
 * \memberof AMdoc
 * \brief Puts a sequence of bytes as the value of a key in a map object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] key A UTF-8 string key for the map object identified by \p obj_id.
 * \param[in] src A pointer to an array of bytes.
 * \param[in] count The number of bytes to copy from \p src.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre \p key `!= NULL`.
 * \pre \p src `!= NULL`.
 * \pre `0 <` \p count `<= sizeof(`\p src`)`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * key must be a c string of the map key to be used
 * src must be a byte array of size `>= count`
 */
struct AMresult *AMmapPutBytes(struct AMdoc *doc, const struct AMobjId *obj_id, const char *key, const uint8_t *src, size_t count);

/**
 * \memberof AMdoc
 * \brief Puts a CRDT counter as the value of a key in a map object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] key A UTF-8 string key for the map object identified by \p obj_id.
 * \param[in] value A 64-bit signed integer.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre \p key `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * key must be a c string of the map key to be used
 */
struct AMresult *AMmapPutCounter(struct AMdoc *doc, const struct AMobjId *obj_id, const char *key, int64_t value);

/**
 * \memberof AMdoc
 * \brief Puts null as the value of a key in a map object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] key A UTF-8 string key for the map object identified by \p obj_id.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre \p key `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * key must be a c string of the map key to be used
 */
struct AMresult *AMmapPutNull(struct AMdoc *doc, const struct AMobjId *obj_id, const char *key);

/**
 * \memberof AMdoc
 * \brief Puts an empty object as the value of a key in a map object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] key A UTF-8 string key for the map object identified by \p obj_id.
 * \param[in] obj_type An `AMobjIdType` enum tag.
 * \return A pointer to an `AMresult` struct containing a pointer to an
 *         `AMobjId` struct.
 * \pre \p doc `!= NULL`.
 * \pre \p key `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * key must be a c string of the map key to be used
 */
struct AMresult *AMmapPutObject(struct AMdoc *doc, const struct AMobjId *obj_id, const char *key, AMobjType obj_type);

/**
 * \memberof AMdoc
 * \brief Puts a float as the value of a key in a map object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] key A UTF-8 string key for the map object identified by \p obj_id.
 * \param[in] value A 64-bit float.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre \p key `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * key must be a c string of the map key to be used
 */
struct AMresult *AMmapPutF64(struct AMdoc *doc, const struct AMobjId *obj_id, const char *key, double value);

/**
 * \memberof AMdoc
 * \brief Puts a signed integer as the value of a key in a map object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] key A UTF-8 string key for the map object identified by \p obj_id.
 * \param[in] value A 64-bit signed integer.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre \p key `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * key must be a c string of the map key to be used
 */
struct AMresult *AMmapPutInt(struct AMdoc *doc, const struct AMobjId *obj_id, const char *key, int64_t value);

/**
 * \memberof AMdoc
 * \brief Puts a UTF-8 string as the value of a key in a map object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] key A UTF-8 string key for the map object identified by \p obj_id.
 * \param[in] value A UTF-8 string.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre \p key `!= NULL`.
 * \pre \p value `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * key must be a c string of the map key to be used
 * value must be a null-terminated array of `c_char`
 */
struct AMresult *AMmapPutStr(struct AMdoc *doc, const struct AMobjId *obj_id, const char *key, const char *value);

/**
 * \memberof AMdoc
 * \brief Puts a Lamport timestamp as the value of a key in a map object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] key A UTF-8 string key for the map object identified by \p obj_id.
 * \param[in] value A 64-bit signed integer.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre \p key `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * key must be a c string of the map key to be used
 */
struct AMresult *AMmapPutTimestamp(struct AMdoc *doc, const struct AMobjId *obj_id, const char *key, int64_t value);

/**
 * \memberof AMdoc
 * \brief Puts an unsigned integer as the value of a key in a map object.
 *
 * \param[in,out] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] key A UTF-8 string key for the map object identified by \p obj_id.
 * \param[in] value A 64-bit unsigned integer.
 * \return A pointer to an `AMresult` struct containing a void.
 * \pre \p doc `!= NULL`.
 * \pre \p key `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * key must be a c string of the map key to be used
 */
struct AMresult *AMmapPutUint(struct AMdoc *doc, const struct AMobjId *obj_id, const char *key, uint64_t value);

/**
 * \memberof AMdoc
 * \brief Gets the current or historical keys and values of the map object
 *        within the given range.
 *
 * \param[in] doc A pointer to an `AMdoc` struct.
 * \param[in] obj_id A pointer to an `AMobjId` struct or `AM_ROOT`.
 * \param[in] begin The first key in a subrange or `NULL` to indicate the
 *                  absolute first key.
 * \param[in] end The key one past the last key in a subrange or `NULL` to
 *                indicate one past the absolute last key.
 * \param[in] heads A pointer to an `AMchangeHashes` struct for historical
 *                  keys and values or `NULL` for current keys and values.
 * \return A pointer to an `AMresult` struct containing an `AMmapItems`
 *         struct.
 * \pre \p doc `!= NULL`.
 * \pre `strcmp(`\p begin, \p end`) != 1` if \p begin `!= NULL` and \p end `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * doc must be a valid pointer to an AMdoc
 * obj_id must be a valid pointer to an AMobjId or std::ptr::null()
 * heads must be a valid pointer to an AMchangeHashes or std::ptr::null()
 */
struct AMresult *AMmapRange(const struct AMdoc *doc,
                            const struct AMobjId *obj_id,
                            const char *begin,
                            const char *end,
                            const struct AMchangeHashes *heads);

/**
 * \memberof AMmapItem
 * \brief Gets the key of an item in a map object.
 *
 * \param[in] map_item A pointer to an `AMmapItem` struct.
 * \return A 64-bit unsigned integer.
 * \pre \p map_item `!= NULL`.
 * \internal
 *
 * # Safety
 * map_item must be a valid pointer to an AMmapItem
 */
const char *AMmapItemKey(const struct AMmapItem *map_item);

/**
 * \memberof AMmapItem
 * \brief Gets the object identifier of an item in a map object.
 *
 * \param[in] map_item A pointer to an `AMmapItem` struct.
 * \return A pointer to an `AMobjId` struct.
 * \pre \p map_item `!= NULL`.
 * \internal
 *
 * # Safety
 * map_item must be a valid pointer to an AMmapItem
 */
const struct AMobjId *AMmapItemObjId(const struct AMmapItem *map_item);

/**
 * \memberof AMmapItem
 * \brief Gets the value of an item in a map object.
 *
 * \param[in] map_item A pointer to an `AMmapItem` struct.
 * \return An `AMvalue` struct.
 * \pre \p map_item `!= NULL`.
 * \internal
 *
 * # Safety
 * map_item must be a valid pointer to an AMmapItem
 */
union AMvalue AMmapItemValue(const struct AMmapItem *map_item);

/**
 * \memberof AMmapItems
 * \brief Advances an iterator over a sequence of map object items by at most
 *        \p |n| positions where the sign of \p n is relative to the
 *        iterator's direction.
 *
 * \param[in,out] map_items A pointer to an `AMmapItems` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \pre \p map_items `!= NULL`.
 * \internal
 *
 * #Safety
 * map_items must be a valid pointer to an AMmapItems
 */
void AMmapItemsAdvance(struct AMmapItems *map_items, ptrdiff_t n);

/**
 * \memberof AMmapItems
 * \brief Tests the equality of two sequences of map object items underlying
 *        a pair of iterators.
 *
 * \param[in] map_items1 A pointer to an `AMmapItems` struct.
 * \param[in] map_items2 A pointer to an `AMmapItems` struct.
 * \return `true` if \p map_items1 `==` \p map_items2 and `false` otherwise.
 * \pre \p map_items1 `!= NULL`.
 * \pre \p map_items2 `!= NULL`.
 * \internal
 *
 * #Safety
 * map_items1 must be a valid pointer to an AMmapItems
 * map_items2 must be a valid pointer to an AMmapItems
 */
bool AMmapItemsEqual(const struct AMmapItems *map_items1, const struct AMmapItems *map_items2);

/**
 * \memberof AMmapItems
 * \brief Gets the map object item at the current position of an iterator
 *        over a sequence of map object items and then advances it by at most
 *        \p |n| positions where the sign of \p n is relative to the
 *        iterator's direction.
 *
 * \param[in,out] map_items A pointer to an `AMmapItems` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \return A pointer to an `AMmapItem` struct that's `NULL` when \p map_items
 *         was previously advanced past its forward/reverse limit.
 * \pre \p map_items `!= NULL`.
 * \internal
 *
 * #Safety
 * map_items must be a valid pointer to an AMmapItems
 */
const struct AMmapItem *AMmapItemsNext(struct AMmapItems *map_items, ptrdiff_t n);

/**
 * \memberof AMmapItems
 * \brief Advances an iterator over a sequence of map object items by at most
 *        \p |n| positions where the sign of \p n is relative to the
 *        iterator's direction and then gets the map object item at its new
 *        position.
 *
 * \param[in,out] map_items A pointer to an `AMmapItems` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \return A pointer to an `AMmapItem` struct that's `NULL` when \p map_items
 *         is presently advanced past its forward/reverse limit.
 * \pre \p map_items `!= NULL`.
 * \internal
 *
 * #Safety
 * map_items must be a valid pointer to an AMmapItems
 */
const struct AMmapItem *AMmapItemsPrev(struct AMmapItems *map_items, ptrdiff_t n);

/**
 * \memberof AMmapItems
 * \brief Gets the size of the sequence of map object items underlying an
 *        iterator.
 *
 * \param[in] map_items A pointer to an `AMmapItems` struct.
 * \return The count of values in \p map_items.
 * \pre \p map_items `!= NULL`.
 * \internal
 *
 * #Safety
 * map_items must be a valid pointer to an AMmapItems
 */
size_t AMmapItemsSize(const struct AMmapItems *map_items);

/**
 * \memberof AMmapItems
 * \brief Creates an iterator over the same sequence of map object items as
 *        the given one but with the opposite position and direction.
 *
 * \param[in] map_items A pointer to an `AMmapItems` struct.
 * \return An `AMmapItems` struct
 * \pre \p map_items `!= NULL`.
 * \internal
 *
 * #Safety
 * map_items must be a valid pointer to an AMmapItems
 */
struct AMmapItems AMmapItemsReversed(const struct AMmapItems *map_items);

/**
 * \memberof AMmapItems
 * \brief Creates an iterator at the starting position over the same sequence of map object items as the given one.
 *
 * \param[in] map_items A pointer to an `AMmapItems` struct.
 * \return An `AMmapItems` struct
 * \pre \p map_items `!= NULL`.
 * \internal
 *
 * #Safety
 * map_items must be a valid pointer to an AMmapItems
 */
struct AMmapItems AMmapItemsRewound(const struct AMmapItems *map_items);

/**
 * \memberof AMobjId
 * \brief Gets the actor identifier of an object identifier.
 *
 * \param[in] obj_id A pointer to an `AMobjId` struct.
 * \return A pointer to an `AMactorId` struct or `NULL`.
 * \pre \p obj_id `!= NULL`.
 * \internal
 *
 * # Safety
 * obj_id must be a valid pointer to an AMobjId
 */
const struct AMactorId *AMobjIdActorId(const struct AMobjId *obj_id);

/**
 * \memberof AMobjId
 * \brief Gets the counter of an object identifier.
 *
 * \param[in] obj_id A pointer to an `AMobjId` struct.
 * \return A 64-bit unsigned integer.
 * \pre \p obj_id `!= NULL`.
 * \internal
 *
 * # Safety
 * obj_id must be a valid pointer to an AMobjId
 */
uint64_t AMobjIdCounter(const struct AMobjId *obj_id);

/**
 * \memberof AMobjId
 * \brief Tests the equality of two object identifiers.
 *
 * \param[in] obj_id1 A pointer to an `AMobjId` struct.
 * \param[in] obj_id2 A pointer to an `AMobjId` struct.
 * \return `true` if \p obj_id1 `==` \p obj_id2 and `false` otherwise.
 * \pre \p obj_id1 `!= NULL`.
 * \pre \p obj_id2 `!= NULL`.
 * \internal
 *
 * #Safety
 * obj_id1 must be a valid AMobjId pointer
 * obj_id2 must be a valid AMobjId pointer
 */
bool AMobjIdEqual(const struct AMobjId *obj_id1, const struct AMobjId *obj_id2);

/**
 * \memberof AMobjId
 * \brief Gets the index of an object identifier.
 *
 * \param[in] obj_id A pointer to an `AMobjId` struct.
 * \return A 64-bit unsigned integer.
 * \pre \p obj_id `!= NULL`.
 * \internal
 *
 * # Safety
 * obj_id must be a valid pointer to an AMobjId
 */
size_t AMobjIdIndex(const struct AMobjId *obj_id);

/**
 * \memberof AMobjItem
 * \brief Gets the object identifier of an item in an object.
 *
 * \param[in] obj_item A pointer to an `AMobjItem` struct.
 * \return A pointer to an `AMobjId` struct.
 * \pre \p obj_item `!= NULL`.
 * \internal
 *
 * # Safety
 * obj_item must be a valid pointer to an AMobjItem
 */
const struct AMobjId *AMobjItemObjId(const struct AMobjItem *obj_item);

/**
 * \memberof AMobjItem
 * \brief Gets the value of an item in an object.
 *
 * \param[in] obj_item A pointer to an `AMobjItem` struct.
 * \return An `AMvalue` struct.
 * \pre \p obj_item `!= NULL`.
 * \internal
 *
 * # Safety
 * obj_item must be a valid pointer to an AMobjItem
 */
union AMvalue AMobjItemValue(const struct AMobjItem *obj_item);

/**
 * \memberof AMobjItems
 * \brief Advances an iterator over a sequence of object items by at most
 *        \p |n| positions where the sign of \p n is relative to the
 *        iterator's direction.
 *
 * \param[in,out] obj_items A pointer to an `AMobjItems` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \pre \p obj_items `!= NULL`.
 * \internal
 *
 * #Safety
 * obj_items must be a valid pointer to an AMobjItems
 */
void AMobjItemsAdvance(struct AMobjItems *obj_items, ptrdiff_t n);

/**
 * \memberof AMobjItems
 * \brief Tests the equality of two sequences of object items underlying a
 *        pair of iterators.
 *
 * \param[in] obj_items1 A pointer to an `AMobjItems` struct.
 * \param[in] obj_items2 A pointer to an `AMobjItems` struct.
 * \return `true` if \p obj_items1 `==` \p obj_items2 and `false` otherwise.
 * \pre \p obj_items1 `!= NULL`.
 * \pre \p obj_items2 `!= NULL`.
 * \internal
 *
 * #Safety
 * obj_items1 must be a valid pointer to an AMobjItems
 * obj_items2 must be a valid pointer to an AMobjItems
 */
bool AMobjItemsEqual(const struct AMobjItems *obj_items1, const struct AMobjItems *obj_items2);

/**
 * \memberof AMobjItems
 * \brief Gets the object item at the current position of an iterator over a
 *        sequence of object items and then advances it by at most \p |n|
 *        positions where the sign of \p n is relative to the iterator's
 *        direction.
 *
 * \param[in,out] obj_items A pointer to an `AMobjItems` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \return A pointer to an `AMobjItem` struct that's `NULL` when \p obj_items
 *         was previously advanced past its forward/reverse limit.
 * \pre \p obj_items `!= NULL`.
 * \internal
 *
 * #Safety
 * obj_items must be a valid pointer to an AMobjItems
 */
const struct AMobjItem *AMobjItemsNext(struct AMobjItems *obj_items, ptrdiff_t n);

/**
 * \memberof AMobjItems
 * \brief Advances an iterator over a sequence of object items by at most
 *        \p |n| positions where the sign of \p n is relative to the
 *        iterator's direction and then gets the object item at its new
 *        position.
 *
 * \param[in,out] obj_items A pointer to an `AMobjItems` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \return A pointer to an `AMobjItem` struct that's `NULL` when \p obj_items
 *         is presently advanced past its forward/reverse limit.
 * \pre \p obj_items `!= NULL`.
 * \internal
 *
 * #Safety
 * obj_items must be a valid pointer to an AMobjItems
 */
const struct AMobjItem *AMobjItemsPrev(struct AMobjItems *obj_items, ptrdiff_t n);

/**
 * \memberof AMobjItems
 * \brief Gets the size of the sequence of object items underlying an
 *        iterator.
 *
 * \param[in] obj_items A pointer to an `AMobjItems` struct.
 * \return The count of values in \p obj_items.
 * \pre \p obj_items `!= NULL`.
 * \internal
 *
 * #Safety
 * obj_items must be a valid pointer to an AMobjItems
 */
size_t AMobjItemsSize(const struct AMobjItems *obj_items);

/**
 * \memberof AMobjItems
 * \brief Creates an iterator over the same sequence of object items as the
 *        given one but with the opposite position and direction.
 *
 * \param[in] obj_items A pointer to an `AMobjItems` struct.
 * \return An `AMobjItems` struct
 * \pre \p obj_items `!= NULL`.
 * \internal
 *
 * #Safety
 * obj_items must be a valid pointer to an AMobjItems
 */
struct AMobjItems AMobjItemsReversed(const struct AMobjItems *obj_items);

/**
 * \memberof AMobjItems
 * \brief Creates an iterator at the starting position over the same sequence
 *        of object items as the given one.
 *
 * \param[in] obj_items A pointer to an `AMobjItems` struct.
 * \return An `AMobjItems` struct
 * \pre \p obj_items `!= NULL`.
 * \internal
 *
 * #Safety
 * obj_items must be a valid pointer to an AMobjItems
 */
struct AMobjItems AMobjItemsRewound(const struct AMobjItems *obj_items);

/**
 * \memberof AMvalue
 * \brief Tests the equality of two values.
 *
 * \param[in] value1 A pointer to an `AMvalue` struct.
 * \param[in] value2 A pointer to an `AMvalue` struct.
 * \return `true` if \p value1 `==` \p value2 and `false` otherwise.
 * \pre \p value1 `!= NULL`.
 * \pre \p value2 `!= NULL`.
 * \internal
 *
 * #Safety
 * value1 must be a valid AMvalue pointer
 * value2 must be a valid AMvalue pointer
 */
bool AMvalueEqual(const union AMvalue *value1, const union AMvalue *value2);

/**
 * \memberof AMresult
 * \brief Gets a result's error message string.
 *
 * \param[in] result A pointer to an `AMresult` struct.
 * \return A UTF-8 string value or `NULL`.
 * \pre \p result `!= NULL`.
 * \internal
 *
 * # Safety
 * result must be a valid pointer to an AMresult
 */
const char *AMerrorMessage(const struct AMresult *result);

/**
 * \memberof AMresult
 * \brief Deallocates the storage for a result.
 *
 * \param[in,out] result A pointer to an `AMresult` struct.
 * \pre \p result `!= NULL`.
 * \internal
 *
 * # Safety
 * result must be a valid pointer to an AMresult
 */
void AMfree(struct AMresult *result);

/**
 * \memberof AMresult
 * \brief Gets the size of a result's value.
 *
 * \param[in] result A pointer to an `AMresult` struct.
 * \return The count of values in \p result.
 * \pre \p result `!= NULL`.
 * \internal
 *
 * # Safety
 * result must be a valid pointer to an AMresult
 */
size_t AMresultSize(const struct AMresult *result);

/**
 * \memberof AMresult
 * \brief Gets the status code of a result.
 *
 * \param[in] result A pointer to an `AMresult` struct.
 * \return An `AMstatus` enum tag.
 * \pre \p result `!= NULL`.
 * \internal
 *
 * # Safety
 * result must be a valid pointer to an AMresult
 */
AMstatus AMresultStatus(const struct AMresult *result);

/**
 * \memberof AMresult
 * \brief Gets a result's value.
 *
 * \param[in] result A pointer to an `AMresult` struct.
 * \return An `AMvalue` struct.
 * \pre \p result `!= NULL`.
 * \internal
 *
 * # Safety
 * result must be a valid pointer to an AMresult
 */
union AMvalue AMresultValue(struct AMresult *result);

/**
 * \memberof AMresultStack
 * \brief Deallocates the storage for a stack of results.
 *
 * \param[in,out] stack A pointer to a pointer to an `AMresultStack` struct.
 * \return The number of `AMresult` structs freed.
 * \pre \p stack `!= NULL`.
 * \post `*stack == NULL`.
 * \note Calling this function is purely optional because its only purpose is
 *       to make memory management tolerable for direct usage of this API in
 *       C, C++ and Objective-C.
 * \internal
 *
 * # Safety
 * stack must be a valid AMresultStack pointer pointer
 */
size_t AMfreeStack(struct AMresultStack **stack);

/**
 * \memberof AMresultStack
 * \brief Gets the topmost result from the stack after removing it.
 *
 * \param[in,out] stack A pointer to a pointer to an `AMresultStack` struct.
 * \return A pointer to an `AMresult` struct or `NULL`.
 * \pre \p stack `!= NULL`.
 * \post `*stack == NULL`.
 * \note Calling this function is purely optional because its only purpose is
 *       to make memory management tolerable for direct usage of this API in
 *       C, C++ and Objective-C.
 * \internal
 *
 * # Safety
 * stack must be a valid AMresultStack pointer pointer
 */
struct AMresult *AMpop(struct AMresultStack **stack);

/**
 * \memberof AMresultStack
 * \brief Pushes the given result onto the given stack and then either extracts
 *        a value matching the given discriminant from that result or,
 *        failing that, calls the given function and gets a void value instead.
 *
 * \param[in,out] stack A pointer to a pointer to an `AMresultStack` struct.
 * \param[in] result A pointer to an `AMresult` struct.
 * \param[in] discriminant An `AMvalue` variant's corresponding enum tag.
 * \param[in] callback A pointer to a function with the same signature as
 *                     `AMpushCallback()` or `NULL`.
 * \return An `AMvalue` struct.
 * \pre \p stack `!= NULL`.
 * \pre \p result `!= NULL`.
 * \warning If \p stack `== NULL` then \p result is deallocated in order to
 *          prevent a memory leak.
 * \note Calling this function is purely optional because its only purpose is
 *       to make memory management tolerable for direct usage of this API in
 *       C, C++ and Objective-C.
 * \internal
 *
 * # Safety
 * stack must be a valid AMresultStack pointer pointer
 * result must be a valid AMresult pointer
 */
union AMvalue AMpush(struct AMresultStack **stack, struct AMresult *result, uint8_t discriminant, AMpushCallback callback);

/**
 * \memberof AMstrs
 * \brief Advances an iterator over a sequence of UTF-8 strings by at most
 *        \p |n| positions where the sign of \p n is relative to the
 *        iterator's direction.
 *
 * \param[in,out] strs A pointer to an `AMstrs` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \pre \p strs `!= NULL`.
 * \internal
 *
 * #Safety
 * strs must be a valid pointer to an AMstrs
 */
void AMstrsAdvance(struct AMstrs *strs, ptrdiff_t n);

/**
 * \memberof AMstrs
 * \brief Compares the sequences of UTF-8 strings underlying a pair of
 *        iterators.
 *
 * \param[in] strs1 A pointer to an `AMstrs` struct.
 * \param[in] strs2 A pointer to an `AMstrs` struct.
 * \return `-1` if \p strs1 `<` \p strs2, `0` if
 *         \p strs1 `==` \p strs2 and `1` if
 *         \p strs1 `>` \p strs2.
 * \pre \p strs1 `!= NULL`.
 * \pre \p strs2 `!= NULL`.
 * \internal
 *
 * #Safety
 * strs1 must be a valid pointer to an AMstrs
 * strs2 must be a valid pointer to an AMstrs
 */
ptrdiff_t AMstrsCmp(const struct AMstrs *strs1, const struct AMstrs *strs2);

/**
 * \memberof AMstrs
 * \brief Gets the key at the current position of an iterator over a sequence
 *        of UTF-8 strings and then advances it by at most \p |n| positions
 *        where the sign of \p n is relative to the iterator's direction.
 *
 * \param[in,out] strs A pointer to an `AMstrs` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \return A UTF-8 string that's `NULL` when \p strs was previously advanced
 *         past its forward/reverse limit.
 * \pre \p strs `!= NULL`.
 * \internal
 *
 * #Safety
 * strs must be a valid pointer to an AMstrs
 */
const char *AMstrsNext(struct AMstrs *strs, ptrdiff_t n);

/**
 * \memberof AMstrs
 * \brief Advances an iterator over a sequence of UTF-8 strings by at most
 *        \p |n| positions where the sign of \p n is relative to the
 *        iterator's direction and then gets the key at its new position.
 *
 * \param[in,out] strs A pointer to an `AMstrs` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \return A UTF-8 string that's `NULL` when \p strs is presently advanced
 *         past its forward/reverse limit.
 * \pre \p strs `!= NULL`.
 * \internal
 *
 * #Safety
 * strs must be a valid pointer to an AMstrs
 */
const char *AMstrsPrev(struct AMstrs *strs, ptrdiff_t n);

/**
 * \memberof AMstrs
 * \brief Gets the size of the sequence of UTF-8 strings underlying an
 *        iterator.
 *
 * \param[in] strs A pointer to an `AMstrs` struct.
 * \return The count of values in \p strs.
 * \pre \p strs `!= NULL`.
 * \internal
 *
 * #Safety
 * strs must be a valid pointer to an AMstrs
 */
size_t AMstrsSize(const struct AMstrs *strs);

/**
 * \memberof AMstrs
 * \brief Creates an iterator over the same sequence of UTF-8 strings as the
 *        given one but with the opposite position and direction.
 *
 * \param[in] strs A pointer to an `AMstrs` struct.
 * \return An `AMstrs` struct.
 * \pre \p strs `!= NULL`.
 * \internal
 *
 * #Safety
 * strs must be a valid pointer to an AMstrs
 */
struct AMstrs AMstrsReversed(const struct AMstrs *strs);

/**
 * \memberof AMstrs
 * \brief Creates an iterator at the starting position over the same sequence
 *        of UTF-8 strings as the given one.
 *
 * \param[in] strs A pointer to an `AMstrs` struct.
 * \return An `AMstrs` struct
 * \pre \p strs `!= NULL`.
 * \internal
 *
 * #Safety
 * strs must be a valid pointer to an AMstrs
 */
struct AMstrs AMstrsRewound(const struct AMstrs *strs);

/**
 * \memberof AMsyncHave
 * \brief Gets the heads of the sender.
 *
 * \param[in] sync_have A pointer to an `AMsyncHave` struct.
 * \return An `AMchangeHashes` struct.
 * \pre \p sync_have `!= NULL`.
 * \internal
 *
 * # Safety
 * sync_have must be a valid pointer to an AMsyncHave
 */
struct AMchangeHashes AMsyncHaveLastSync(const struct AMsyncHave *sync_have);

/**
 * \memberof AMsyncHaves
 * \brief Advances an iterator over a sequence of synchronization haves by at
 *        most \p |n| positions where the sign of \p n is relative to the
 *        iterator's direction.
 *
 * \param[in,out] sync_haves A pointer to an `AMsyncHaves` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \pre \p sync_haves `!= NULL`.
 * \internal
 *
 * #Safety
 * sync_haves must be a valid pointer to an AMsyncHaves
 */
void AMsyncHavesAdvance(struct AMsyncHaves *sync_haves, ptrdiff_t n);

/**
 * \memberof AMsyncHaves
 * \brief Tests the equality of two sequences of synchronization haves
 *        underlying a pair of iterators.
 *
 * \param[in] sync_haves1 A pointer to an `AMsyncHaves` struct.
 * \param[in] sync_haves2 A pointer to an `AMsyncHaves` struct.
 * \return `true` if \p sync_haves1 `==` \p sync_haves2 and `false` otherwise.
 * \pre \p sync_haves1 `!= NULL`.
 * \pre \p sync_haves2 `!= NULL`.
 * \internal
 *
 * #Safety
 * sync_haves1 must be a valid pointer to an AMsyncHaves
 * sync_haves2 must be a valid pointer to an AMsyncHaves
 */
bool AMsyncHavesEqual(const struct AMsyncHaves *sync_haves1, const struct AMsyncHaves *sync_haves2);

/**
 * \memberof AMsyncHaves
 * \brief Gets the synchronization have at the current position of an iterator
 *        over a sequence of synchronization haves and then advances it by at
 *        most \p |n| positions where the sign of \p n is relative to the
 *        iterator's direction.
 *
 * \param[in,out] sync_haves A pointer to an `AMsyncHaves` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \return A pointer to an `AMsyncHave` struct that's `NULL` when
 *         \p sync_haves was previously advanced past its forward/reverse
 *         limit.
 * \pre \p sync_haves `!= NULL`.
 * \internal
 *
 * #Safety
 * sync_haves must be a valid pointer to an AMsyncHaves
 */
const struct AMsyncHave *AMsyncHavesNext(struct AMsyncHaves *sync_haves, ptrdiff_t n);

/**
 * \memberof AMsyncHaves
 * \brief Advances an iterator over a sequence of synchronization haves by at
 *        most \p |n| positions where the sign of \p n is relative to the
 *        iterator's direction and then gets the synchronization have at its
 *        new position.
 *
 * \param[in,out] sync_haves A pointer to an `AMsyncHaves` struct.
 * \param[in] n The direction (\p -n -> opposite, \p n -> same) and maximum
 *              number of positions to advance.
 * \return A pointer to an `AMsyncHave` struct that's `NULL` when
 *         \p sync_haves is presently advanced past its forward/reverse limit.
 * \pre \p sync_haves `!= NULL`.
 * \internal
 *
 * #Safety
 * sync_haves must be a valid pointer to an AMsyncHaves
 */
const struct AMsyncHave *AMsyncHavesPrev(struct AMsyncHaves *sync_haves, ptrdiff_t n);

/**
 * \memberof AMsyncHaves
 * \brief Gets the size of the sequence of synchronization haves underlying an
 *        iterator.
 *
 * \param[in] sync_haves A pointer to an `AMsyncHaves` struct.
 * \return The count of values in \p sync_haves.
 * \pre \p sync_haves `!= NULL`.
 * \internal
 *
 * #Safety
 * sync_haves must be a valid pointer to an AMsyncHaves
 */
size_t AMsyncHavesSize(const struct AMsyncHaves *sync_haves);

/**
 * \memberof AMsyncHaves
 * \brief Creates an iterator over the same sequence of synchronization haves
 *        as the given one but with the opposite position and direction.
 *
 * \param[in] sync_haves A pointer to an `AMsyncHaves` struct.
 * \return An `AMsyncHaves` struct
 * \pre \p sync_haves `!= NULL`.
 * \internal
 *
 * #Safety
 * sync_haves must be a valid pointer to an AMsyncHaves
 */
struct AMsyncHaves AMsyncHavesReversed(const struct AMsyncHaves *sync_haves);

/**
 * \memberof AMsyncHaves
 * \brief Creates an iterator at the starting position over the same sequence
 *        of synchronization haves as the given one.
 *
 * \param[in] sync_haves A pointer to an `AMsyncHaves` struct.
 * \return An `AMsyncHaves` struct
 * \pre \p sync_haves `!= NULL`.
 * \internal
 *
 * #Safety
 * sync_haves must be a valid pointer to an AMsyncHaves
 */
struct AMsyncHaves AMsyncHavesRewound(const struct AMsyncHaves *sync_haves);

/**
 * \memberof AMsyncMessage
 * \brief Gets the changes for the recipient to apply.
 *
 * \param[in] sync_message A pointer to an `AMsyncMessage` struct.
 * \return An `AMchanges` struct.
 * \pre \p sync_message `!= NULL`.
 * \internal
 *
 * # Safety
 * sync_message must be a valid pointer to an AMsyncMessage
 */
struct AMchanges AMsyncMessageChanges(const struct AMsyncMessage *sync_message);

/**
 * \memberof AMsyncMessage
 * \brief Decodes a sequence of bytes into a synchronization message.
 *
 * \param[in] src A pointer to an array of bytes.
 * \param[in] count The number of bytes in \p src to decode.
 * \return A pointer to an `AMresult` struct containing an `AMsyncMessage`
 *         struct.
 * \pre \p src `!= NULL`.
 * \pre `0 <` \p count `<= sizeof(`\p src`)`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * src must be a byte array of size `>= count`
 */
struct AMresult *AMsyncMessageDecode(const uint8_t *src, size_t count);

/**
 * \memberof AMsyncMessage
 * \brief Encodes a synchronization message as a sequence of bytes.
 *
 * \param[in] sync_message A pointer to an `AMsyncMessage` struct.
 * \return A pointer to an `AMresult` struct containing an array of bytes as
 *         an `AMbyteSpan` struct.
 * \pre \p sync_message `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * sync_message must be a valid pointer to an AMsyncMessage
 */
struct AMresult *AMsyncMessageEncode(const struct AMsyncMessage *sync_message);

/**
 * \memberof AMsyncMessage
 * \brief Gets a summary of the changes that the sender already has.
 *
 * \param[in] sync_message A pointer to an `AMsyncMessage` struct.
 * \return An `AMhaves` struct.
 * \pre \p sync_message `!= NULL`.
 * \internal
 *
 * # Safety
 * sync_message must be a valid pointer to an AMsyncMessage
 */
struct AMsyncHaves AMsyncMessageHaves(const struct AMsyncMessage *sync_message);

/**
 * \memberof AMsyncMessage
 * \brief Gets the heads of the sender.
 *
 * \param[in] sync_message A pointer to an `AMsyncMessage` struct.
 * \return An `AMchangeHashes` struct.
 * \pre \p sync_message `!= NULL`.
 * \internal
 *
 * # Safety
 * sync_message must be a valid pointer to an AMsyncMessage
 */
struct AMchangeHashes AMsyncMessageHeads(const struct AMsyncMessage *sync_message);

/**
 * \memberof AMsyncMessage
 * \brief Gets the hashes of any changes that are being explicitly requested
 *        by the recipient.
 *
 * \param[in] sync_message A pointer to an `AMsyncMessage` struct.
 * \return An `AMchangeHashes` struct.
 * \pre \p sync_message `!= NULL`.
 * \internal
 *
 * # Safety
 * sync_message must be a valid pointer to an AMsyncMessage
 */
struct AMchangeHashes AMsyncMessageNeeds(const struct AMsyncMessage *sync_message);

/**
 * \memberof AMsyncState
 * \brief Decodes a sequence of bytes into a synchronization state.
 *
 * \param[in] src A pointer to an array of bytes.
 * \param[in] count The number of bytes in \p src to decode.
 * \return A pointer to an `AMresult` struct containing an `AMsyncState`
 *         struct.
 * \pre \p src `!= NULL`.
 * \pre `0 <` \p count `<= sizeof(`\p src`)`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * src must be a byte array of size `>= count`
 */
struct AMresult *AMsyncStateDecode(const uint8_t *src, size_t count);

/**
 * \memberof AMsyncState
 * \brief Encodes a synchronizaton state as a sequence of bytes.
 *
 * \param[in] sync_state A pointer to an `AMsyncState` struct.
 * \return A pointer to an `AMresult` struct containing an array of bytes as
 *         an `AMbyteSpan` struct.
 * \pre \p sync_state `!= NULL`.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 * \internal
 * # Safety
 * sync_state must be a valid pointer to an AMsyncState
 */
struct AMresult *AMsyncStateEncode(const struct AMsyncState *sync_state);

/**
 * \memberof AMsyncState
 * \brief Tests the equality of two synchronization states.
 *
 * \param[in] sync_state1 A pointer to an `AMsyncState` struct.
 * \param[in] sync_state2 A pointer to an `AMsyncState` struct.
 * \return `true` if \p sync_state1 `==` \p sync_state2 and `false` otherwise.
 * \pre \p sync_state1 `!= NULL`.
 * \pre \p sync_state2 `!= NULL`.
 * \internal
 *
 * #Safety
 * sync_state1 must be a valid pointer to an AMsyncState
 * sync_state2 must be a valid pointer to an AMsyncState
 */
bool AMsyncStateEqual(const struct AMsyncState *sync_state1, const struct AMsyncState *sync_state2);

/**
 * \memberof AMsyncState
 * \brief Allocates a new synchronization state and initializes it with
 *        defaults.
 *
 * \return A pointer to an `AMresult` struct containing a pointer to an
 *         `AMsyncState` struct.
 * \warning The returned `AMresult` struct must be deallocated with `AMfree()`
 *          in order to prevent a memory leak.
 */
struct AMresult *AMsyncStateInit(void);

/**
 * \memberof AMsyncState
 * \brief Gets the heads that are shared by both peers.
 *
 * \param[in] sync_state A pointer to an `AMsyncState` struct.
 * \return An `AMchangeHashes` struct.
 * \pre \p sync_state `!= NULL`.
 * \internal
 *
 * # Safety
 * sync_state must be a valid pointer to an AMsyncState
 */
struct AMchangeHashes AMsyncStateSharedHeads(const struct AMsyncState *sync_state);

/**
 * \memberof AMsyncState
 * \brief Gets the heads that were last sent by this peer.
 *
 * \param[in] sync_state A pointer to an `AMsyncState` struct.
 * \return An `AMchangeHashes` struct.
 * \pre \p sync_state `!= NULL`.
 * \internal
 *
 * # Safety
 * sync_state must be a valid pointer to an AMsyncState
 */
struct AMchangeHashes AMsyncStateLastSentHeads(const struct AMsyncState *sync_state);

/**
 * \memberof AMsyncState
 * \brief Gets a summary of the changes that the other peer already has.
 *
 * \param[in] sync_state A pointer to an `AMsyncState` struct.
 * \param[out] has_value A pointer to a boolean flag that is set to `true` if
 *             the returned `AMhaves` struct is relevant, `false` otherwise.
 * \return An `AMhaves` struct.
 * \pre \p sync_state `!= NULL`.
 * \pre \p has_value `!= NULL`.
 * \internal
 *
 * # Safety
 * sync_state must be a valid pointer to an AMsyncState
 * has_value must be a valid pointer to a bool.
 */
struct AMsyncHaves AMsyncStateTheirHaves(const struct AMsyncState *sync_state, bool *has_value);

/**
 * \memberof AMsyncState
 * \brief Gets the heads that were sent by the other peer.
 *
 * \param[in] sync_state A pointer to an `AMsyncState` struct.
 * \param[out] has_value A pointer to a boolean flag that is set to `true` if
 *             the returned `AMchangeHashes` struct is relevant, `false`
 *             otherwise.
 * \return An `AMchangeHashes` struct.
 * \pre \p sync_state `!= NULL`.
 * \pre \p has_value `!= NULL`.
 * \internal
 *
 * # Safety
 * sync_state must be a valid pointer to an AMsyncState
 * has_value must be a valid pointer to a bool.
 */
struct AMchangeHashes AMsyncStateTheirHeads(const struct AMsyncState *sync_state, bool *has_value);

/**
 * \memberof AMsyncState
 * \brief Gets the needs that were sent by the other peer.
 *
 * \param[in] sync_state A pointer to an `AMsyncState` struct.
 * \param[out] has_value A pointer to a boolean flag that is set to `true` if
 *             the returned `AMchangeHashes` struct is relevant, `false`
 *             otherwise.
 * \return An `AMchangeHashes` struct.
 * \pre \p sync_state `!= NULL`.
 * \pre \p has_value `!= NULL`.
 * \internal
 *
 * # Safety
 * sync_state must be a valid pointer to an AMsyncState
 * has_value must be a valid pointer to a bool.
 */
struct AMchangeHashes AMsyncStateTheirNeeds(const struct AMsyncState *sync_state, bool *has_value);

#endif /* AUTOMERGE_H */
